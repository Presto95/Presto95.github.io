<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="컬렉션 클래스Foundation 프레임워크는 여러 객체를 저장하거나 객체를 묶음 단위로 관리하기 위한 다양한 컬렉션 클래스를 제공하며, 이는 순서대로 저장하는 배열, 고유한 키 값으로 접근하는 사전(딕셔너리) 형태, 순서 없이 골라 담는 집합 형태, 배열을 변형한 형태 등을 포함한다. 순서가 있는 배열 컬렉션NSArray &#x2F; NSMutableArray NS">
<meta property="og:type" content="article">
<meta property="og:title" content="Cocoa Internals - 컬렉션 클래스">
<meta property="og:url" content="http://presto95.github.io/2020/01/18/Cocoa-Internals-%EC%BB%AC%EB%A0%89%EC%85%98-%ED%81%B4%EB%9E%98%EC%8A%A4/index.html">
<meta property="og:site_name" content="Presto">
<meta property="og:description" content="컬렉션 클래스Foundation 프레임워크는 여러 객체를 저장하거나 객체를 묶음 단위로 관리하기 위한 다양한 컬렉션 클래스를 제공하며, 이는 순서대로 저장하는 배열, 고유한 키 값으로 접근하는 사전(딕셔너리) 형태, 순서 없이 골라 담는 집합 형태, 배열을 변형한 형태 등을 포함한다. 순서가 있는 배열 컬렉션NSArray &#x2F; NSMutableArray NS">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-01-17T15:54:25.000Z">
<meta property="article:modified_time" content="2020-01-17T15:54:38.720Z">
<meta property="article:author" content="Presto">
<meta property="article:tag" content="ios">
<meta property="article:tag" content="cocoa">
<meta name="twitter:card" content="summary">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>Cocoa Internals - 컬렉션 클래스</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/css/rtl.css">

    
    <!-- rss -->
    
    
<meta name="generator" content="Hexo 4.2.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Posts</a></li>
         
          <li><a href="/tags/">Tag</a></li>
         
          <li><a href="/categories/">Category</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2020/01/18/Cocoa-Internals-%EC%BD%94%EC%BD%94%EC%95%84-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2020/01/18/Cocoa-Internals-%EB%B6%88%EB%B3%80-%EA%B0%9D%EC%B2%B4%EC%99%80-%EA%B0%80%EB%B3%80-%EA%B0%9D%EC%B2%B4/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://presto95.github.io/2020/01/18/Cocoa-Internals-%EC%BB%AC%EB%A0%89%EC%85%98-%ED%81%B4%EB%9E%98%EC%8A%A4/" target="_blank" rel="noopener"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://presto95.github.io/2020/01/18/Cocoa-Internals-%EC%BB%AC%EB%A0%89%EC%85%98-%ED%81%B4%EB%9E%98%EC%8A%A4/&text=Cocoa Internals - 컬렉션 클래스" target="_blank" rel="noopener"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://presto95.github.io/2020/01/18/Cocoa-Internals-%EC%BB%AC%EB%A0%89%EC%85%98-%ED%81%B4%EB%9E%98%EC%8A%A4/&title=Cocoa Internals - 컬렉션 클래스" target="_blank" rel="noopener"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://presto95.github.io/2020/01/18/Cocoa-Internals-%EC%BB%AC%EB%A0%89%EC%85%98-%ED%81%B4%EB%9E%98%EC%8A%A4/&is_video=false&description=Cocoa Internals - 컬렉션 클래스" target="_blank" rel="noopener"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Cocoa Internals - 컬렉션 클래스&body=Check out this article: http://presto95.github.io/2020/01/18/Cocoa-Internals-%EC%BB%AC%EB%A0%89%EC%85%98-%ED%81%B4%EB%9E%98%EC%8A%A4/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://presto95.github.io/2020/01/18/Cocoa-Internals-%EC%BB%AC%EB%A0%89%EC%85%98-%ED%81%B4%EB%9E%98%EC%8A%A4/&title=Cocoa Internals - 컬렉션 클래스" target="_blank" rel="noopener"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://presto95.github.io/2020/01/18/Cocoa-Internals-%EC%BB%AC%EB%A0%89%EC%85%98-%ED%81%B4%EB%9E%98%EC%8A%A4/&title=Cocoa Internals - 컬렉션 클래스" target="_blank" rel="noopener"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://presto95.github.io/2020/01/18/Cocoa-Internals-%EC%BB%AC%EB%A0%89%EC%85%98-%ED%81%B4%EB%9E%98%EC%8A%A4/&title=Cocoa Internals - 컬렉션 클래스" target="_blank" rel="noopener"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://presto95.github.io/2020/01/18/Cocoa-Internals-%EC%BB%AC%EB%A0%89%EC%85%98-%ED%81%B4%EB%9E%98%EC%8A%A4/&title=Cocoa Internals - 컬렉션 클래스" target="_blank" rel="noopener"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://presto95.github.io/2020/01/18/Cocoa-Internals-%EC%BB%AC%EB%A0%89%EC%85%98-%ED%81%B4%EB%9E%98%EC%8A%A4/&name=Cocoa Internals - 컬렉션 클래스&description=" target="_blank" rel="noopener"><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://news.ycombinator.com/submitlink?u=http://presto95.github.io/2020/01/18/Cocoa-Internals-%EC%BB%AC%EB%A0%89%EC%85%98-%ED%81%B4%EB%9E%98%EC%8A%A4/&t=Cocoa Internals - 컬렉션 클래스" target="_blank" rel="noopener"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#컬렉션-클래스"><span class="toc-number">1.</span> <span class="toc-text">컬렉션 클래스</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#순서가-있는-배열-컬렉션"><span class="toc-number">1.1.</span> <span class="toc-text">순서가 있는 배열 컬렉션</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#불변-배열과-가변-배열"><span class="toc-number">1.1.0.1.</span> <span class="toc-text">불변 배열과 가변 배열</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#탐색-정렬-필터링"><span class="toc-number">1.1.0.2.</span> <span class="toc-text">탐색, 정렬, 필터링</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#널-가능성과-제네릭"><span class="toc-number">1.1.0.3.</span> <span class="toc-text">널 가능성과 제네릭</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#배열-성능-특성"><span class="toc-number">1.1.1.</span> <span class="toc-text">배열 성능 특성</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#포인터-배열"><span class="toc-number">1.1.2.</span> <span class="toc-text">포인터 배열</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#방법1-정해진-옵션-지정하기"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">방법1. 정해진 옵션 지정하기</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#방법2-함수-포인터-지정-방식"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">방법2. 함수 포인터 지정 방식</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#중첩된-배열-접근하기"><span class="toc-number">1.1.3.</span> <span class="toc-text">중첩된 배열 접근하기</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Swift-배열"><span class="toc-number">1.1.4.</span> <span class="toc-text">Swift 배열</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#요약"><span class="toc-number">1.1.5.</span> <span class="toc-text">요약</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#고유한-키-값으로-접근하는-사전-컬렉션"><span class="toc-number">1.2.</span> <span class="toc-text">고유한 키 값으로 접근하는 사전 컬렉션</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#사전-활용-방법"><span class="toc-number">1.2.1.</span> <span class="toc-text">사전 활용 방법</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#불변-사전과-가변-사전"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">불변 사전과 가변 사전</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#나만의-키-객체"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">나만의 키 객체</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#사전-데이터-정렬"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">사전 데이터 정렬</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#사전-데이터-필터링"><span class="toc-number">1.2.1.4.</span> <span class="toc-text">사전 데이터 필터링</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#포인터-사전"><span class="toc-number">1.2.2.</span> <span class="toc-text">포인터 사전</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#NSMapTable-설정-옵션-지정"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">NSMapTable 설정 옵션 지정</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#함수-포인터-방식"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">함수 포인터 방식</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#사전-성능-특성"><span class="toc-number">1.2.3.</span> <span class="toc-text">사전 성능 특성</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Swift-사전"><span class="toc-number">1.2.4.</span> <span class="toc-text">Swift 사전</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#네이티브-사전-저장-구조"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">네이티브 사전 저장 구조</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Cocoa-연결-저장-구조"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">Cocoa 연결 저장 구조</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#요약-1"><span class="toc-number">1.2.5.</span> <span class="toc-text">요약</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#순서가-없는-집합-컬렉션"><span class="toc-number">1.3.</span> <span class="toc-text">순서가 없는 집합 컬렉션</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#집합-활용-방법"><span class="toc-number">1.3.1.</span> <span class="toc-text">집합 활용 방법</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#가변-집합과-불변-집합"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">가변 집합과 불변 집합</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#집합-연산과-중복-가능-집합-NSCountedSet"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">집합 연산과 중복 가능 집합(NSCountedSet)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#포인터-집합"><span class="toc-number">1.3.2.</span> <span class="toc-text">포인터 집합</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#설정-옵션-지정"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">설정 옵션 지정</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#함수-포인터-지정"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">함수 포인터 지정</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#사전-성능-특성-1"><span class="toc-number">1.3.3.</span> <span class="toc-text">사전 성능 특성</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Swift-집합"><span class="toc-number">1.3.4.</span> <span class="toc-text">Swift 집합</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#요약-2"><span class="toc-number">1.3.5.</span> <span class="toc-text">요약</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#집합-변형-컬렉션"><span class="toc-number">1.4.</span> <span class="toc-text">집합 변형 컬렉션</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#배열-인덱스를-저장하는-인덱스-집합"><span class="toc-number">1.4.1.</span> <span class="toc-text">배열 인덱스를 저장하는 인덱스 집합</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#인덱스-집합-활용-방법"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">인덱스 집합 활용 방법</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#순서가-있는-집합"><span class="toc-number">1.4.2.</span> <span class="toc-text">순서가 있는 집합</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#요약-3"><span class="toc-number">1.4.3.</span> <span class="toc-text">요약</span></a></li></ol></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        Cocoa Internals - 컬렉션 클래스
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Presto</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2020-01-17T15:54:25.000Z" itemprop="datePublished">2020-01-18</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        <a class="category-link" href="/categories/iOS/">iOS</a>
    </div>


      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/tags/cocoa/" rel="tag">cocoa</a>, <a class="tag-link" href="/tags/ios/" rel="tag">ios</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h1 id="컬렉션-클래스"><a href="#컬렉션-클래스" class="headerlink" title="컬렉션 클래스"></a>컬렉션 클래스</h1><p>Foundation 프레임워크는 여러 객체를 저장하거나 객체를 묶음 단위로 관리하기 위한 다양한 컬렉션 클래스를 제공하며, 이는 순서대로 저장하는 배열, 고유한 키 값으로 접근하는 사전(딕셔너리) 형태, 순서 없이 골라 담는 집합 형태, 배열을 변형한 형태 등을 포함한다.</p>
<h2 id="순서가-있는-배열-컬렉션"><a href="#순서가-있는-배열-컬렉션" class="headerlink" title="순서가 있는 배열 컬렉션"></a>순서가 있는 배열 컬렉션</h2><p><code>NSArray</code> / <code>NSMutableArray</code></p>
<p><code>NSObject</code>를 상속받는 어떠한 객체라도 위의 배열에 객체에 대한 레퍼런스를 저장할 수 있다.</p>
<p>배열에 비어 있는 상태를 표현하려면 <code>[NSNull null]</code> 형태의 빈 객체 인스턴스를 넣으면 된다.</p>
<h4 id="불변-배열과-가변-배열"><a href="#불변-배열과-가변-배열" class="headerlink" title="불변 배열과 가변 배열"></a>불변 배열과 가변 배열</h4><p>배열에 변경을 가해야 할 때뿐만 아니라, 배열이 너무 큰 경우에도 가변 배열을 사용하는 것이 좋다.</p>
<p>참조 객체는 해당 객체를 복사하는 것이 아닌, 해당 객체에 대한 소유권을 획득하여 참조하는 형태다. ARC가 아닌 환경에서는 <code>-retain</code> 메소드를 통해 소유권을 획득한다.</p>
<p>배열을 복사하고 싶다면 <code>-initWithArray:copyItems</code>와 같은 초기화 메소드를 사용한다.</p>
<h4 id="탐색-정렬-필터링"><a href="#탐색-정렬-필터링" class="headerlink" title="탐색, 정렬, 필터링"></a>탐색, 정렬, 필터링</h4><p>탐색에 있어서 <code>for-in</code> 구문을 사용하는 빠른 탐색<em>fast enumeration</em>이 권장되며, <code>-enumerateObjectsUsingBlock:</code>을 사용하는 것도 좋다. 이는 블록 기반으로 작동한다.</p>
<p>정렬에 있어서 정렬 설명서<em>sort descriptor</em>를 사용한다. <code>-sortedArrayUsingComparator:</code>와 같은 블록 기반 메소드도 사용할 수 있다.</p>
<p>필터링에 있어서 <code>NSPredicate</code> 클래스를 사용하여 필터링 조건을 만든다. <code>-filteredArrayUsingPredicate:</code>와 같은 블록 기반 메소드를 사용할 수 있다.</p>
<h4 id="널-가능성과-제네릭"><a href="#널-가능성과-제네릭" class="headerlink" title="널 가능성과 제네릭"></a>널 가능성과 제네릭</h4><p>iOS 9, macOS 10.11부터 컬렉션 클래스가 제네릭 타입을 지원하게 되었고, Swift와의 호환성을 위해 객체나 타입 변수가 <code>nil</code> 값을 가질 수 있는지에 대해 표시하는 널 가능성 지시어가 추가되었다.</p>
<ul>
<li><code>_Nonnull</code><ul>
<li><code>nil</code> 값을 가질 수 없음을 의미한다.</li>
</ul>
</li>
<li><code>_Nullable</code><ul>
<li><code>nil</code> 값을 가질 수 있음을 의미한다. 말하자면 Swift의 <code>Int?</code>와 동일한 의미를 갖는다.</li>
</ul>
</li>
<li><code>_Null_resetable</code><ul>
<li><code>nil</code> 값을 가질 수 있으나 명시적으로 <code>nil</code> 값은 절대 되지 않음을 의미한다. 말하자면 Swift의 <code>Int!</code>와 동일한 의미를 갖는다.</li>
</ul>
</li>
<li><code>_Null_unspecified</code><ul>
<li><code>nil</code> 여부를 판단하지 않음을 의미한다.</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ (instancetype _Nonnull)arrayWithArray:(NSArray&lt;ObjectType&gt;) * _Nonnull)anArray</span><br></pre></td></tr></table></figure>

<p><code>+arrayWithArray:</code> 메소드의 구현은 인자로 <code>nil</code>인 값이 들어올 수 없고 <code>nil</code>인 값을 반환할 수 없음을 의미한다.</p>
<p>기존에 <code>NSArray</code>가 제네릭 타입이 아니었을 때는 타입이 다른 객체를 얼마든지 넣을 수 있었으나 현재는 제네릭을 지원하므로 특정 클래스만 담는 컬렉션으로 활용 가능하다.</p>
<p>상속을 받아 사용하는 하위 클래스를 포함하여 제네릭으로 선언하고 싶으면 <code>__kindof</code> 지시어를 사용해야 한다. (<code>NSArray&lt;__kindof UIView*&gt; *subviews</code>)</p>
<h3 id="배열-성능-특성"><a href="#배열-성능-특성" class="headerlink" title="배열 성능 특성"></a>배열 성능 특성</h3><p><code>NSArray</code>와 무비용 연결이 가능한 <code>CFArray</code>와의 성능 차이를 비교한 결과 다음의 것들을 얻을 수 있었다.</p>
<ul>
<li><code>CFArray</code>보다 <code>NSArray</code>가 성능상 우수하다.</li>
<li>서브스크립트 또는 <code>objectAtIndex:</code>로 배열의 요소에 접근하는 것보다 <code>for-in</code> 구문을 사용한 빠른 탐색을 하는 것이 성능상 우수하다.</li>
</ul>
<h3 id="포인터-배열"><a href="#포인터-배열" class="headerlink" title="포인터 배열"></a>포인터 배열</h3><p><code>NSPointerArray</code></p>
<p>포인터 배열을 사용하여 참조 객체를 약한 참조로 접근할 수 있다.</p>
<p>포인터 배열을 생성하는 방법은,</p>
<ol>
<li>이미 정의되어 있는 메모리 관리 방식과 포인터 특성에 대한 선택 사항 고르기</li>
<li>포인터 함수 직접 지정하기</li>
</ol>
<p>두 가지 방법이 있다.</p>
<h4 id="방법1-정해진-옵션-지정하기"><a href="#방법1-정해진-옵션-지정하기" class="headerlink" title="방법1. 정해진 옵션 지정하기"></a>방법1. 정해진 옵션 지정하기</h4><p><code>-initWithOptions:</code></p>
<p><code>NSPointerFunctionsOptions</code> 옵션에서 선택한다. 이는 메모리 관리 방식에 관한 것과 포인터의 특성에 관한 것으로 구분된다.</p>
<h4 id="방법2-함수-포인터-지정-방식"><a href="#방법2-함수-포인터-지정-방식" class="headerlink" title="방법2. 함수 포인터 지정 방식"></a>방법2. 함수 포인터 지정 방식</h4><p><code>-initWithPointerFunctions</code></p>
<p><code>NSPointerFunctions</code>를 활용하여 포인터에 있는 데이터를 다룰 함수 포인터를 지정하는 방식을 취한다.</p>
<p>이는 다음의 함수 등을 포함한다.</p>
<ul>
<li><code>hashFunction</code> : 함수의 등가성을 판단하기 위함</li>
<li><code>isEqualFunction</code> : 함수의 등가성을 판단하기 위함</li>
<li><code>descriptionFunction</code> : 요소를 묘사하기 위함</li>
<li><code>acquireFunction</code> : 메모리 할당을 위함</li>
<li><code>relinquishFunction</code> : 메모리 해제를 위함</li>
</ul>
<h3 id="중첩된-배열-접근하기"><a href="#중첩된-배열-접근하기" class="headerlink" title="중첩된 배열 접근하기"></a>중첩된 배열 접근하기</h3><p><code>NSIndexPath</code> 객체를 사용하여 중첩된 배열의 참조 인덱스를 따라간다.</p>
<p>이전 iOS 버전의 <code>UITableView</code>에서 사용된 <code>NSIndexPath</code>에는 <code>row</code>와 <code>section</code>에 대한 정보가 없으며, 이는 <code>UITableView</code>에 대하여 카테고리를 통해 확장된 것들이다.</p>
<h3 id="Swift-배열"><a href="#Swift-배열" class="headerlink" title="Swift 배열"></a>Swift 배열</h3><p>Swift의 배열은 구조체 타입이며, 여러 프로토콜을 채택하여 확장되었다.</p>
<p>구현 방식에 따라 <code>Array&lt;Element&gt;</code>, <code>ContiguousArray&lt;Element&gt;</code>, <code>ArraySlice&lt;Element&gt;</code>로 나뉜다.</p>
<ul>
<li><code>ContiguousArray</code>는 메모리의 연속된 영역에 요소를 저장한다.</li>
<li><code>ArraySlice</code>는 배열을 잘라서 일부 요소만 표현할 수 있도록 도와준다.</li>
<li><code>Array</code>만 <code>NSArray</code>와 연결될 수 있다.</li>
</ul>
<p>Swift의 배열은 일반적으로 value semantics를 갖고 있느나, 요소에 클래스 타입을 포함하는 경우 Objective-C와의 호환을 위해 reference semantics를 갖게 된다.</p>
<p>Swift의 배열은 Copy-on-Write를 지원한다.</p>
<ul>
<li>배열을 복사했을 때, 복사한 것과 복사된 것은 초기에 서로 같은 메모리를 참조한다.</li>
<li>복사 이후 배열의 한 곳을 변경하는 시점에 실제 복사가 이루어진다.<ul>
<li>이는 배열 전체 길이만큼 영향을 주므로 O(N)의 복잡도를 갖게 된다.</li>
</ul>
</li>
</ul>
<p>Swift의 배열은 요소가 클래스이거나 <code>@objc</code> 프로토콜을 지원하는 타입인 경우 내부 <code>NSArray</code>에 저장된다. 이 떄문에 <code>NSArray</code>와 연결하는 복잡도는 O(1)이 된다.</p>
<h3 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h3><p>배열 객체의 성능 특성을 알고 시스템 자원을 효과적으로 사용하는 것은 중요하다.</p>
<p>포인터 배열의 특징을 이해하고 있다면 적합한 상황에 골라 사용할 수 있다.</p>
<h2 id="고유한-키-값으로-접근하는-사전-컬렉션"><a href="#고유한-키-값으로-접근하는-사전-컬렉션" class="headerlink" title="고유한 키 값으로 접근하는 사전 컬렉션"></a>고유한 키 값으로 접근하는 사전 컬렉션</h2><p>딕셔너리<em>Dictionary</em>. 고유한 키와 키에 매칭하는 값을 갖는 자료 타입.</p>
<p>Cocoa에서는 서로 매칭되는 키와 값을 짝지어 하나의 개체<em>entity</em>라고 부른다.</p>
<p>동일한 키 값이 존재하면 안되므로, 키 값으로 사용하는 객체는 <code>hash</code> 및 <code>isEqual</code> 메소드를 구현하여 등가성을 판단할 수 있어야 하고, 복사를 위한 <code>NSCopying</code> 프로토콜을 지원해야 한다.</p>
<p>Swift의 경우 <code>Hashable</code> 프로토콜을 준수하는 타입이 딕셔너리의 키 값으로 사용될 수 있다.</p>
<h3 id="사전-활용-방법"><a href="#사전-활용-방법" class="headerlink" title="사전 활용 방법"></a>사전 활용 방법</h3><h4 id="불변-사전과-가변-사전"><a href="#불변-사전과-가변-사전" class="headerlink" title="불변 사전과 가변 사전"></a>불변 사전과 가변 사전</h4><p>딕셔너리에 변경을 가해야 할 때뿐만 아니라, 딕셔너리가 너무 큰 경우에도 가변 배열을 사용하는 것이 좋다.</p>
<p><code>NSDictionary</code>를 사용하여 불변 객체를 만들었다 할지라도, 그 요소가 가변 객체이면 그것에 대한 변경은 이루어질 수 있다.</p>
<p>참조 객체는 해당 객체를 복사하는 것이 아닌, 해당 객체에 대한 소유권을 획득하여 참조하는 형태다. ARC가 아닌 환경에서는 <code>-retain</code> 메소드를 통해 소유권을 획득한다.</p>
<p>딕셔너리를 복사하고 싶다면 <code>-initWithDictionary:copyItems</code>와 같은 초기화 메소드를 사용한다.</p>
<h4 id="나만의-키-객체"><a href="#나만의-키-객체" class="headerlink" title="나만의 키 객체"></a>나만의 키 객체</h4><p>딕셔너리의 키 값은 유일해야 하고, 그 값 비교를 위해 해시 방식을 지원해야 한다.</p>
<p>자신만의 객체를 키 값으로 사용하려 한다면 <code>-hash</code> 및 <code>-isEqual</code> 메소드를 구현해야 한다.</p>
<p>키 객체의 해시 함수 결과가 충돌하지 않는 안전한 함수라면 개체 탐색, 추가, 삭제 모두 O(N)의 복잡도를 갖게 된다.</p>
<p>일반적으로 <code>NSString</code>(<code>String</code>)을 키 값으로 사용하므로 안정적인 <code>NSString</code> 해시 함수를 사용하게 된다.</p>
<p>키 객체는 반드시 <code>NSCopying</code> 프로토콜을 구현하여 내부적으로 복사가 일어나도록 해야 한다. 키-값 쌍으로 딕셔너리에 추가된 개체의 키 값은 변경되면 안되기 때문이다.</p>
<blockquote>
<p><code>NSCache</code>의 경우 키 객체에 대한 복사가 이루어지지 않는다.</p>
</blockquote>
<h4 id="사전-데이터-정렬"><a href="#사전-데이터-정렬" class="headerlink" title="사전 데이터 정렬"></a>사전 데이터 정렬</h4><p>딕셔너리의 정렬 결과는 <code>NSArray</code> 배열 객체로 반환된다.</p>
<blockquote>
<p>Swift의 딕셔너리의 정렬 결과는 키와 값을 튜플의 형태로 갖는 배열로 반환된다.</p>
</blockquote>
<p>정렬 비교용 메소드를 만들어 넘기거나, <code>NSComparator</code> 타입 블록을 넘겨서 키 값을 정렬한다.</p>
<h4 id="사전-데이터-필터링"><a href="#사전-데이터-필터링" class="headerlink" title="사전 데이터 필터링"></a>사전 데이터 필터링</h4><p>블록을 사용하여 조건이 참인 키 값만 집합의 형태로 반환한다.</p>
<h3 id="포인터-사전"><a href="#포인터-사전" class="headerlink" title="포인터 사전"></a>포인터 사전</h3><p><code>NSMapTable</code></p>
<p>포인터 딕셔너리를 활용하여 약한 참조로 객체를 매칭하거나, 값에 객체가 아닌 포인터를 참조하고 싶거나, 키 값도 포인터를 참조하고 싶은 경우 사용할 수 있다.</p>
<p>포인터 딕셔너리를 생성하는 두 가지 방법이 있다.</p>
<h4 id="NSMapTable-설정-옵션-지정"><a href="#NSMapTable-설정-옵션-지정" class="headerlink" title="NSMapTable 설정 옵션 지정"></a>NSMapTable 설정 옵션 지정</h4><p><code>-initWithKeyOptions:valueOptions:capacity:</code></p>
<p><code>NSPointerFunctionsOptions</code> 설정 값을 지정하며, 키와 값에 대해 각각 다른 옵션을 설정할 수 있다.</p>
<h4 id="함수-포인터-방식"><a href="#함수-포인터-방식" class="headerlink" title="함수 포인터 방식"></a>함수 포인터 방식</h4><p><code>-initWithKeyPointerFunctions:valuePointerFunctions:capacity:</code></p>
<p><code>NSPointerFunctions</code>를 사용하여 키에 대한 함수 포인터와 값에 대한 함수 포인터를 따로 지정한다.</p>
<h3 id="사전-성능-특성"><a href="#사전-성능-특성" class="headerlink" title="사전 성능 특성"></a>사전 성능 특성</h3><p><code>NSDictionary</code>는 <code>CFDictionary</code>와 무비용 연결될 수 있다. 이 둘은 성능상 동일한 복잡도를 갖는다.</p>
<p>빠른 탐색이 성능상 효과적이다.</p>
<h3 id="Swift-사전"><a href="#Swift-사전" class="headerlink" title="Swift 사전"></a>Swift 사전</h3><p><code>Dictionary</code>는 구조체. 네이티브 저장 방식과 Cocoa 저장 방식을 모두 구현하고 있다.</p>
<h4 id="네이티브-사전-저장-구조"><a href="#네이티브-사전-저장-구조" class="headerlink" title="네이티브 사전 저장 구조"></a>네이티브 사전 저장 구조</h4><ul>
<li>딕셔너리 내부의 여러 종류 타입의 값을 저장하기 위한 <code>_VariantDictionaryStorage</code> 데이터가 <code>_NativeDictionaryStorageOwner</code> 클래스를 참조한다.</li>
<li><code>_NativeDictionaryStorageOwner</code> 클래스는 Swift 네이티브 타입을 저장할 때는 <code>_NativeDictionaryStorageImpl</code> 클래스를 참조하도록 내부 저장 구조를 바꾼다.<ul>
<li><code>NativeDictionaryStorageOwner</code> 클래스는 Objective-C 객체를 저장하기 위해 <code>NSDictionary</code> 클래스와 연결 가능하도록 <code>NSDictionary</code>를 상속받아 구현되었다.</li>
</ul>
</li>
</ul>
<h4 id="Cocoa-연결-저장-구조"><a href="#Cocoa-연결-저장-구조" class="headerlink" title="Cocoa 연결 저장 구조"></a>Cocoa 연결 저장 구조</h4><ul>
<li>딕셔너리 내부의 여러 종류 타입의 값을 저장하기 위한 <code>_VariantDictionaryStorage</code> 데이터에 있는 <code>_CocoaDictionaryStorage</code> 구조체가 <code>NSDictionary</code> 클래스를 참조한다.</li>
</ul>
<p>네이티브 딕셔너리를 <code>NSDictionary</code>와 연결하려면 먼저 키와 값 모두 연결된 상태여야 한다.</p>
<p><code>Dictionary&lt;K, V&gt;.Index</code>로 색인 접근이 가능하다. 이를 통해 바로 이전/다음 요소를 추가할 때 메모리를 재할당하지 않고 곧바로 저장할 수 있다.</p>
<p>하지만 여러 스레드에서 동시에 접근하는 경우나 딕셔너리 메모리 버퍼에 대한 경계 검사를 하는 경우에 이는 좋은 방법이 아니다.</p>
<h3 id="요약-1"><a href="#요약-1" class="headerlink" title="요약"></a>요약</h3><p><code>NSDictionary</code>는 키와 값을 짝지어 다루는 데이터 구조.</p>
<p>키 값은 고유해야 하므로 키 값으로 사용될 수 있는 객체의 특성을 이해해야 한다.</p>
<p>키와 값을 객체가 아닌 포인터 타입으로 지정하려면 <code>NSMapTable</code>을 사용할 수 있다. (iOS에서는 키나 값에 객체가 아닌 포인터를 지정할 수 없다.)</p>
<h2 id="순서가-없는-집합-컬렉션"><a href="#순서가-없는-집합-컬렉션" class="headerlink" title="순서가 없는 집합 컬렉션"></a>순서가 없는 집합 컬렉션</h2><p><code>NSSet</code>, 집합. 순서 없이 동일한 객체를 중복 참조하지 않는 컬렉션.</p>
<p>컬렉션 내부 참조 객체의 존재 여부를 확인하는 경우에는 배열보다는 집합을 사용하는 것이 성능상 더 좋다.</p>
<h3 id="집합-활용-방법"><a href="#집합-활용-방법" class="headerlink" title="집합 활용 방법"></a>집합 활용 방법</h3><ul>
<li><code>NSSet</code> : 불변 집합. <code>CFSetRef</code>와 무비용 연결.</li>
<li><code>NSMutableSet</code> : 가변 집합. <code>CFMutableSetRef</code>와 무비용 연결.</li>
<li><code>NSCountedSet</code> : 동일한 객체가 중복해서 들어갈 수 있는 집합. <code>CFBagRef</code>와 무비용 연결.</li>
</ul>
<h4 id="가변-집합과-불변-집합"><a href="#가변-집합과-불변-집합" class="headerlink" title="가변 집합과 불변 집합"></a>가변 집합과 불변 집합</h4><p><code>-hash</code>와 <code>-isEqual</code> 메소드를 통해 객체 간 동일성을 판단한다.</p>
<p>집합에 변경을 가해야 할 때뿐만 아니라, 집합 요소가 너무 큰 경우에도 가변 집합을 사용하는 것이 좋다.</p>
<p>참조 객체는 해당 객체를 복사하는 것이 아닌, 해당 객체에 대한 소유권을 획득하여 참조하는 형태다. ARC가 아닌 환경에서는 <code>-retain</code> 메소드를 통해 소유권을 획득한다.</p>
<p>참조할 객체를 복사하려면 <code>-initWithSet:copyItems</code>와 같은 초기화 메소드를 사용할 수 있다.</p>
<p>집합 내부에 동일한 객체를 여러 번 참조하도록 하려면 <code>NSCountedSet</code>을 사용하는 것이 좋다.</p>
<h4 id="집합-연산과-중복-가능-집합-NSCountedSet"><a href="#집합-연산과-중복-가능-집합-NSCountedSet" class="headerlink" title="집합 연산과 중복 가능 집합(NSCountedSet)"></a>집합 연산과 중복 가능 집합(NSCountedSet)</h4><ul>
<li><code>unionSet:</code> : 합집합 연산</li>
<li><code>minusSet:</code> : 차집합 연산</li>
<li><code>intersectSet</code> : 교집합 연산</li>
</ul>
<p><code>NSCountedSet</code>의 경우 집합 연산은 다음과 깉이 이루어진다.</p>
<ul>
<li>합집합 연산의 경우, 중복된 항목이 있는 경우 해당 항목에 대한 카운트가 올라간다.</li>
<li>교집합 연산의 경우, 양쪽에 적어도 하나만 있으면 교집합에 추가되고, 양쪽 모두에 중복해서 여러 개 있는 경우 카운트가 올라간다.</li>
<li>차집합 연산의 경우, 집합 내부 카운트끼리 빼기가 되어 카운트가 1보다 큰 경우만 집합에 남는다.</li>
</ul>
<h3 id="포인터-집합"><a href="#포인터-집합" class="headerlink" title="포인터 집합"></a>포인터 집합</h3><p><code>NSHashTable</code>. 포인터 값을 집합 형태로 저장하기 위해 사용한다.</p>
<p>요소를 약한 참조하고 싶거나 객체가 아닌 포인터를 참조하고 싶은 경우 <code>NSHashTable</code>을 사용할 수 있다.</p>
<p>포인터 집합을 생성하는 두 가지 방법이 있다.</p>
<h4 id="설정-옵션-지정"><a href="#설정-옵션-지정" class="headerlink" title="설정 옵션 지정"></a>설정 옵션 지정</h4><p><code>-initWithOptions:capacity:</code></p>
<p><code>NSPointerFunctionsOptions</code> 설정 값을 지정한다. <code>nil</code> 포인터는 추가할 수 없다.</p>
<h4 id="함수-포인터-지정"><a href="#함수-포인터-지정" class="headerlink" title="함수 포인터 지정"></a>함수 포인터 지정</h4><p><code>-initWithPointerFunctions:capacity:</code></p>
<p><code>NSPointerFunctions</code>를 활용하여 함수 포인터를 넘겨준다.</p>
<h3 id="사전-성능-특성-1"><a href="#사전-성능-특성-1" class="headerlink" title="사전 성능 특성"></a>사전 성능 특성</h3><p><code>NSSet</code>과 무비용 연결 가능한 <code>CFBag</code>와는 성능상 동일한 복잡도를 가진다.</p>
<p>요소 포함 여부(<code>containsObject:</code>)를 판단하는 경우 <code>NSArray</code>는 O(N<sup>2</sup>)의 복잡도를 보여주나 <code>NSSet</code>의 경우 O(N)의 복잡도를 보여주었다. </p>
<p>따라서 객체 포함 여부를 판단하는 경우에는 집합 계열 컬렉션을 사용하는 것이 좋다.</p>
<h3 id="Swift-집합"><a href="#Swift-집합" class="headerlink" title="Swift 집합"></a>Swift 집합</h3><p><code>Set</code>. 배열이나 딕셔너라 타입보다 상대적으로 성능 특성이나 최적화에 대한 고려가 덜 되어 있다.</p>
<p>내부에 데이터 요소를 저장하는 <code>_VariantStorage</code> 열거 타입 변수를 가지고 있으며, 이것이 <code>.native</code>이면 네이티브 저장소를 만들고, <code>.cocoa</code>이면 <code>NSSet</code> 객체를 연결하여 참조한다.</p>
<p><code>NSSet</code>과 연결하기 위해 <code>as</code> 연산자를 사용할 수 있으며, 집합에 저장하는 요소가 반드시 클래스 타입이거나 <code>@objc</code> 프로토콜 속성을 만족해야 한다.</p>
<p>이러한 경우 <code>NSSet</code>과 연결할 때의 복잡도는 O(1)이며, 집합의 요소가 클래스 타입이 아니거나 <code>@objc</code> 프로토콜 속성을 만족하지 않는 경우 O(N)의 복잡도를 갑는다.</p>
<p><code>NSSet</code>을 <code>Set</code>과 연결하는 복잡도는 O(1)인데, 복사된 불변 객체를 Swift 네이티브 집합에 참조하도록 하는 과정만 거치기 때문이다.</p>
<h3 id="요약-2"><a href="#요약-2" class="headerlink" title="요약"></a>요약</h3><p><code>NSSet</code> 계열 집합 컬렉션은 순서 없이 여러 객체를 집합에 넣고 포함되어 있는지를 판단하기 위한 데이터 구조로 많이 사용된다.</p>
<p><code>NSCountedSet</code>을 사용하여 집합에 객체가 여러 번 들어가도록 할 수 있다.</p>
<p><code>NSHashTable</code>을 사용하여 객체가 아닌 포인터 타입을 집합에 보관하도록 할 수 있다. (iOS에서는 포인터 타입을 사용할 수 없다.)</p>
<h2 id="집합-변형-컬렉션"><a href="#집합-변형-컬렉션" class="headerlink" title="집합 변형 컬렉션"></a>집합 변형 컬렉션</h2><h3 id="배열-인덱스를-저장하는-인덱스-집합"><a href="#배열-인덱스를-저장하는-인덱스-집합" class="headerlink" title="배열 인덱스를 저장하는 인덱스 집합"></a>배열 인덱스를 저장하는 인덱스 집합</h3><p><code>NSIndexSet</code>. 집합의 특성을 그대로 보유하며, 고유한 인덱스 값의 집합이다. 각 인덱스는 <code>NSRange</code> 구조체를 활용한다.</p>
<h4 id="인덱스-집합-활용-방법"><a href="#인덱스-집합-활용-방법" class="headerlink" title="인덱스 집합 활용 방법"></a>인덱스 집합 활용 방법</h4><p>불변 객체 <code>NSIndexSet</code>과 가변 객체 <code>NSMutableIndexSet</code>을 제공한다.</p>
<p><code>-addIndex:</code>와 <code>-addIndexsInRange:</code>처럼 <code>Int</code> 또는 <code>NSRange</code>를 사용하여 집합에 인덱스 값이나 범위를 추가할 수 있다.</p>
<h3 id="순서가-있는-집합"><a href="#순서가-있는-집합" class="headerlink" title="순서가 있는 집합"></a>순서가 있는 집합</h3><p><code>NSOrderedSet</code>. 집합의 특성과 배열의 특성을 모두 갖는다.</p>
<p>Core Data 내부적으로 이것을 사용한다고 알려져 있다.</p>
<p>배열처럼 순차 접근이 가능하고, 집합이므로 포함 연산에 용이하다. 포함 연산의 경우 <code>NSSet</code>과 비교하여 약 10%의 성능 부하가 있다.</p>
<h3 id="요약-3"><a href="#요약-3" class="headerlink" title="요약"></a>요약</h3><p><code>NSIndexSet</code>은 <code>NSArray</code> 내부의 특정 객체들에 대한 인덱스를 저장하기 적합하다. <code>NSArray</code>는 <code>NSIndexSet</code>을 만들어내는 메소드를 가지고 있다.</p>
<p><code>NSOrderedSet</code>은 배열의 특성과 집합의 특성을 모두 가지고 있으며 <code>NSArray</code>와 <code>NSSet</code>보다 성능이 조금 좋지 않다.</p>

  </div>
</article>

    <div class="blog-post-comments">
        <div id="disqus_thread">
            <noscript>Please enable JavaScript to view the comments.</noscript>
        </div>
    </div>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Posts</a></li>
         
          <li><a href="/tags/">Tag</a></li>
         
          <li><a href="/categories/">Category</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#컬렉션-클래스"><span class="toc-number">1.</span> <span class="toc-text">컬렉션 클래스</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#순서가-있는-배열-컬렉션"><span class="toc-number">1.1.</span> <span class="toc-text">순서가 있는 배열 컬렉션</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#불변-배열과-가변-배열"><span class="toc-number">1.1.0.1.</span> <span class="toc-text">불변 배열과 가변 배열</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#탐색-정렬-필터링"><span class="toc-number">1.1.0.2.</span> <span class="toc-text">탐색, 정렬, 필터링</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#널-가능성과-제네릭"><span class="toc-number">1.1.0.3.</span> <span class="toc-text">널 가능성과 제네릭</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#배열-성능-특성"><span class="toc-number">1.1.1.</span> <span class="toc-text">배열 성능 특성</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#포인터-배열"><span class="toc-number">1.1.2.</span> <span class="toc-text">포인터 배열</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#방법1-정해진-옵션-지정하기"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">방법1. 정해진 옵션 지정하기</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#방법2-함수-포인터-지정-방식"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">방법2. 함수 포인터 지정 방식</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#중첩된-배열-접근하기"><span class="toc-number">1.1.3.</span> <span class="toc-text">중첩된 배열 접근하기</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Swift-배열"><span class="toc-number">1.1.4.</span> <span class="toc-text">Swift 배열</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#요약"><span class="toc-number">1.1.5.</span> <span class="toc-text">요약</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#고유한-키-값으로-접근하는-사전-컬렉션"><span class="toc-number">1.2.</span> <span class="toc-text">고유한 키 값으로 접근하는 사전 컬렉션</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#사전-활용-방법"><span class="toc-number">1.2.1.</span> <span class="toc-text">사전 활용 방법</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#불변-사전과-가변-사전"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">불변 사전과 가변 사전</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#나만의-키-객체"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">나만의 키 객체</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#사전-데이터-정렬"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">사전 데이터 정렬</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#사전-데이터-필터링"><span class="toc-number">1.2.1.4.</span> <span class="toc-text">사전 데이터 필터링</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#포인터-사전"><span class="toc-number">1.2.2.</span> <span class="toc-text">포인터 사전</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#NSMapTable-설정-옵션-지정"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">NSMapTable 설정 옵션 지정</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#함수-포인터-방식"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">함수 포인터 방식</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#사전-성능-특성"><span class="toc-number">1.2.3.</span> <span class="toc-text">사전 성능 특성</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Swift-사전"><span class="toc-number">1.2.4.</span> <span class="toc-text">Swift 사전</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#네이티브-사전-저장-구조"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">네이티브 사전 저장 구조</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Cocoa-연결-저장-구조"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">Cocoa 연결 저장 구조</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#요약-1"><span class="toc-number">1.2.5.</span> <span class="toc-text">요약</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#순서가-없는-집합-컬렉션"><span class="toc-number">1.3.</span> <span class="toc-text">순서가 없는 집합 컬렉션</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#집합-활용-방법"><span class="toc-number">1.3.1.</span> <span class="toc-text">집합 활용 방법</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#가변-집합과-불변-집합"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">가변 집합과 불변 집합</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#집합-연산과-중복-가능-집합-NSCountedSet"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">집합 연산과 중복 가능 집합(NSCountedSet)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#포인터-집합"><span class="toc-number">1.3.2.</span> <span class="toc-text">포인터 집합</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#설정-옵션-지정"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">설정 옵션 지정</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#함수-포인터-지정"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">함수 포인터 지정</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#사전-성능-특성-1"><span class="toc-number">1.3.3.</span> <span class="toc-text">사전 성능 특성</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Swift-집합"><span class="toc-number">1.3.4.</span> <span class="toc-text">Swift 집합</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#요약-2"><span class="toc-number">1.3.5.</span> <span class="toc-text">요약</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#집합-변형-컬렉션"><span class="toc-number">1.4.</span> <span class="toc-text">집합 변형 컬렉션</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#배열-인덱스를-저장하는-인덱스-집합"><span class="toc-number">1.4.1.</span> <span class="toc-text">배열 인덱스를 저장하는 인덱스 집합</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#인덱스-집합-활용-방법"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">인덱스 집합 활용 방법</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#순서가-있는-집합"><span class="toc-number">1.4.2.</span> <span class="toc-text">순서가 있는 집합</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#요약-3"><span class="toc-number">1.4.3.</span> <span class="toc-text">요약</span></a></li></ol></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://presto95.github.io/2020/01/18/Cocoa-Internals-%EC%BB%AC%EB%A0%89%EC%85%98-%ED%81%B4%EB%9E%98%EC%8A%A4/" target="_blank" rel="noopener"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://presto95.github.io/2020/01/18/Cocoa-Internals-%EC%BB%AC%EB%A0%89%EC%85%98-%ED%81%B4%EB%9E%98%EC%8A%A4/&text=Cocoa Internals - 컬렉션 클래스" target="_blank" rel="noopener"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://presto95.github.io/2020/01/18/Cocoa-Internals-%EC%BB%AC%EB%A0%89%EC%85%98-%ED%81%B4%EB%9E%98%EC%8A%A4/&title=Cocoa Internals - 컬렉션 클래스" target="_blank" rel="noopener"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://presto95.github.io/2020/01/18/Cocoa-Internals-%EC%BB%AC%EB%A0%89%EC%85%98-%ED%81%B4%EB%9E%98%EC%8A%A4/&is_video=false&description=Cocoa Internals - 컬렉션 클래스" target="_blank" rel="noopener"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Cocoa Internals - 컬렉션 클래스&body=Check out this article: http://presto95.github.io/2020/01/18/Cocoa-Internals-%EC%BB%AC%EB%A0%89%EC%85%98-%ED%81%B4%EB%9E%98%EC%8A%A4/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://presto95.github.io/2020/01/18/Cocoa-Internals-%EC%BB%AC%EB%A0%89%EC%85%98-%ED%81%B4%EB%9E%98%EC%8A%A4/&title=Cocoa Internals - 컬렉션 클래스" target="_blank" rel="noopener"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://presto95.github.io/2020/01/18/Cocoa-Internals-%EC%BB%AC%EB%A0%89%EC%85%98-%ED%81%B4%EB%9E%98%EC%8A%A4/&title=Cocoa Internals - 컬렉션 클래스" target="_blank" rel="noopener"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://presto95.github.io/2020/01/18/Cocoa-Internals-%EC%BB%AC%EB%A0%89%EC%85%98-%ED%81%B4%EB%9E%98%EC%8A%A4/&title=Cocoa Internals - 컬렉션 클래스" target="_blank" rel="noopener"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://presto95.github.io/2020/01/18/Cocoa-Internals-%EC%BB%AC%EB%A0%89%EC%85%98-%ED%81%B4%EB%9E%98%EC%8A%A4/&title=Cocoa Internals - 컬렉션 클래스" target="_blank" rel="noopener"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://presto95.github.io/2020/01/18/Cocoa-Internals-%EC%BB%AC%EB%A0%89%EC%85%98-%ED%81%B4%EB%9E%98%EC%8A%A4/&name=Cocoa Internals - 컬렉션 클래스&description=" target="_blank" rel="noopener"><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://news.ycombinator.com/submitlink?u=http://presto95.github.io/2020/01/18/Cocoa-Internals-%EC%BB%AC%EB%A0%89%EC%85%98-%ED%81%B4%EB%9E%98%EC%8A%A4/&t=Cocoa Internals - 컬렉션 클래스" target="_blank" rel="noopener"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2020 Presto
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Posts</a></li>
         
          <li><a href="/tags/">Tag</a></li>
         
          <li><a href="/categories/">Category</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">


<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">


    <!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>

<!-- clipboard -->

  
<script src="/lib/clipboard/clipboard.min.js"></script>

  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Disqus Comments -->

    <script type="text/javascript">
        var disqus_shortname = 'presto95';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>


</body>
</html>
