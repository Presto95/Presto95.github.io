<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="가상기억장치배경프로그램을 실행하는 동안 프로그램 전체를 모두 사용하지는 않는다. 예를 들어, 오류를 처리하는 루틴은 오류가 발생하지 않으면 사용되지 않으며, 배열 &#x2F; 연결 리스트 &#x2F; 테이블과 같은 구조는 실제로 사용되는 공간보다 많은 공간을 할당하여 사용한다. 또한 프로그램의 일부 기능과 특징은 거의 사용되지 않는 경우가 많다. 말하자면, 프로그램을 실행하">
<meta property="og:type" content="article">
<meta property="og:title" content="운영체제 강의노트 정리 - 가상기억장치">
<meta property="og:url" content="http://presto95.github.io/2020/01/18/os-lecture-note-virtual-memory/index.html">
<meta property="og:site_name" content="Presto">
<meta property="og:description" content="가상기억장치배경프로그램을 실행하는 동안 프로그램 전체를 모두 사용하지는 않는다. 예를 들어, 오류를 처리하는 루틴은 오류가 발생하지 않으면 사용되지 않으며, 배열 &#x2F; 연결 리스트 &#x2F; 테이블과 같은 구조는 실제로 사용되는 공간보다 많은 공간을 할당하여 사용한다. 또한 프로그램의 일부 기능과 특징은 거의 사용되지 않는 경우가 많다. 말하자면, 프로그램을 실행하">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-01-17T15:24:24.000Z">
<meta property="article:modified_time" content="2020-01-17T15:24:39.605Z">
<meta property="article:author" content="Presto">
<meta property="article:tag" content="operating system">
<meta name="twitter:card" content="summary">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>운영체제 강의노트 정리 - 가상기억장치</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/css/rtl.css">

    
    <!-- rss -->
    
    
<meta name="generator" content="Hexo 4.2.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Posts</a></li>
         
          <li><a href="/tags/">Tag</a></li>
         
          <li><a href="/categories/">Category</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2020/01/18/os-lecture-note-file-system-interface/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2020/01/18/os-lecture-note-main-memory-management/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://presto95.github.io/2020/01/18/os-lecture-note-virtual-memory/" target="_blank" rel="noopener"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://presto95.github.io/2020/01/18/os-lecture-note-virtual-memory/&text=운영체제 강의노트 정리 - 가상기억장치" target="_blank" rel="noopener"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://presto95.github.io/2020/01/18/os-lecture-note-virtual-memory/&title=운영체제 강의노트 정리 - 가상기억장치" target="_blank" rel="noopener"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://presto95.github.io/2020/01/18/os-lecture-note-virtual-memory/&is_video=false&description=운영체제 강의노트 정리 - 가상기억장치" target="_blank" rel="noopener"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=운영체제 강의노트 정리 - 가상기억장치&body=Check out this article: http://presto95.github.io/2020/01/18/os-lecture-note-virtual-memory/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://presto95.github.io/2020/01/18/os-lecture-note-virtual-memory/&title=운영체제 강의노트 정리 - 가상기억장치" target="_blank" rel="noopener"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://presto95.github.io/2020/01/18/os-lecture-note-virtual-memory/&title=운영체제 강의노트 정리 - 가상기억장치" target="_blank" rel="noopener"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://presto95.github.io/2020/01/18/os-lecture-note-virtual-memory/&title=운영체제 강의노트 정리 - 가상기억장치" target="_blank" rel="noopener"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://presto95.github.io/2020/01/18/os-lecture-note-virtual-memory/&title=운영체제 강의노트 정리 - 가상기억장치" target="_blank" rel="noopener"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://presto95.github.io/2020/01/18/os-lecture-note-virtual-memory/&name=운영체제 강의노트 정리 - 가상기억장치&description=" target="_blank" rel="noopener"><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://news.ycombinator.com/submitlink?u=http://presto95.github.io/2020/01/18/os-lecture-note-virtual-memory/&t=운영체제 강의노트 정리 - 가상기억장치" target="_blank" rel="noopener"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#가상기억장치"><span class="toc-number">1.</span> <span class="toc-text">가상기억장치</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#배경"><span class="toc-number">1.1.</span> <span class="toc-text">배경</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#요구-페이징"><span class="toc-number">1.2.</span> <span class="toc-text">요구 페이징</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#기본-개념"><span class="toc-number">1.2.1.</span> <span class="toc-text">기본 개념</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#요구-페이징의-성능"><span class="toc-number">1.2.2.</span> <span class="toc-text">요구 페이징의 성능</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#프로세스-생성"><span class="toc-number">1.3.</span> <span class="toc-text">프로세스 생성</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Copy-on-Write"><span class="toc-number">1.3.1.</span> <span class="toc-text">Copy-on-Write</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#기억장치-사상-파일"><span class="toc-number">1.3.2.</span> <span class="toc-text">기억장치-사상 파일</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#페이지-교체"><span class="toc-number">1.4.</span> <span class="toc-text">페이지 교체</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#기본-방법"><span class="toc-number">1.4.1.</span> <span class="toc-text">기본 방법</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FIFO-페이지-교체-알고리즘"><span class="toc-number">1.4.2.</span> <span class="toc-text">FIFO 페이지 교체 알고리즘</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OPT-페이지-교체-알고리즘"><span class="toc-number">1.4.3.</span> <span class="toc-text">OPT 페이지 교체 알고리즘</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LRU-페이지-교체-알고리즘"><span class="toc-number">1.4.4.</span> <span class="toc-text">LRU 페이지 교체 알고리즘</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#근접-LRU-페이지-교체-알고리즘"><span class="toc-number">1.4.5.</span> <span class="toc-text">근접 LRU 페이지 교체 알고리즘</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#추가-참조-비트-알고리즘"><span class="toc-number">1.4.5.1.</span> <span class="toc-text">추가 참조 비트 알고리즘</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#기회를-한번-더-주는-알고리즘"><span class="toc-number">1.4.5.2.</span> <span class="toc-text">기회를 한번 더 주는 알고리즘</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#확장된-클럭-알고리즘"><span class="toc-number">1.4.5.3.</span> <span class="toc-text">확장된 클럭 알고리즘</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#계수-기반-페이지-교체-알고리즘"><span class="toc-number">1.4.6.</span> <span class="toc-text">계수 기반 페이지 교체 알고리즘</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#페이지-버퍼링-알고리즘"><span class="toc-number">1.4.7.</span> <span class="toc-text">페이지 버퍼링 알고리즘</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#프레임-할당"><span class="toc-number">1.5.</span> <span class="toc-text">프레임 할당</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#최저-프레임-수"><span class="toc-number">1.5.1.</span> <span class="toc-text">최저 프레임 수</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#할당-알고리즘"><span class="toc-number">1.5.2.</span> <span class="toc-text">할당 알고리즘</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#광역-및-지역-할당"><span class="toc-number">1.5.3.</span> <span class="toc-text">광역 및 지역 할당</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#스레싱"><span class="toc-number">1.6.</span> <span class="toc-text">스레싱</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#스레싱의-원인"><span class="toc-number">1.6.1.</span> <span class="toc-text">스레싱의 원인</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#작업-집합-모델"><span class="toc-number">1.6.2.</span> <span class="toc-text">작업 집합 모델</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#페이지-결함-빈도"><span class="toc-number">1.6.3.</span> <span class="toc-text">페이지 결함 빈도</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#다른-고려"><span class="toc-number">1.7.</span> <span class="toc-text">다른 고려</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#선페이징"><span class="toc-number">1.7.1.</span> <span class="toc-text">선페이징</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#페이지의-크기"><span class="toc-number">1.7.2.</span> <span class="toc-text">페이지의 크기</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TLB-범위"><span class="toc-number">1.7.3.</span> <span class="toc-text">TLB 범위</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#프로그램의-구조"><span class="toc-number">1.7.4.</span> <span class="toc-text">프로그램의 구조</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#페이지-잠금"><span class="toc-number">1.7.5.</span> <span class="toc-text">페이지 잠금</span></a></li></ol></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        운영체제 강의노트 정리 - 가상기억장치
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Presto</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2020-01-17T15:24:24.000Z" itemprop="datePublished">2020-01-18</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        <a class="category-link" href="/categories/Operating-System/">Operating System</a>
    </div>


      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/tags/operating-system/" rel="tag">operating system</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h1 id="가상기억장치"><a href="#가상기억장치" class="headerlink" title="가상기억장치"></a>가상기억장치</h1><h2 id="배경"><a href="#배경" class="headerlink" title="배경"></a>배경</h2><p>프로그램을 실행하는 동안 프로그램 전체를 모두 사용하지는 않는다.</p>
<p>예를 들어, 오류를 처리하는 루틴은 오류가 발생하지 않으면 사용되지 않으며, 배열 / 연결 리스트 / 테이블과 같은 구조는 실제로 사용되는 공간보다 많은 공간을 할당하여 사용한다. 또한 프로그램의 일부 기능과 특징은 거의 사용되지 않는 경우가 많다.</p>
<p>말하자면, 프로그램을 실행하는 어느 한 순간에 프로그램 전체를 필요로 하지 않는다.</p>
<p>프로그램의 일부만 주기억 장치에 올려 실행 가능하도록 하면, 프로그램은 물리적 주기억 장치의 크기에 제한을 받지 않게 되고, 여러 프로그램을 주기억 장치에 적재할 수 있게 되며, 프로그램을 적재하는데 걸리는 입출력 비용을 줄일 수 있다.</p>
<p>가상 기억 장치는 <strong>요구 페이징<em>demand paging</em></strong> 기법을 이용하여 위를 구현한다. 이 때 세그먼테이션과 결합하여 사용될 수 있다.</p>
<h2 id="요구-페이징"><a href="#요구-페이징" class="headerlink" title="요구 페이징"></a>요구 페이징</h2><p>요구 페이징은 스와핑과 페이징을 결합하여 사용한다. 이는 프로세스 전체를 스왑하지 않고, <strong>지연 스와퍼<em>lazy swapper</em></strong>를 사용하여, 페이지가 필요한 경우에만 주기억 장치에 적재한다.</p>
<p>페이징에서는 스와퍼라는 용어 대신 <strong>페이저<em>pager</em></strong>라는 용어를 사용한다.</p>
<h3 id="기본-개념"><a href="#기본-개념" class="headerlink" title="기본 개념"></a>기본 개념</h3><p>프로세스가 스왑 인 될 때 페이저는 어떤 페이지를 사용할지 추측한 다음 그 페이지들만 스왑 인 한다.</p>
<p>이를 위해 주기억 장치에 있는 페이지와 디스크에 있는 페이지를 구분할 수 있어야 하며, 유효 비트를 사용하여 구분한다.</p>
<p>유효 비트가 1이면 주기억 장치에 있는, 0이면 디스크에 있거나 가상 주소 공간에 포함되지 않은 페이지임을 의미한다.</p>
<p>프로세스가 주기억 장치에 적재되지 않은 페이지에 접근하는 경우, 다음의 절차에 따라 그 페이지를 주기억 장치에 적재한다.</p>
<ol>
<li>유효 비트가 0이므로 <strong>페이지 결함 트랩<em>page fault trap</em></strong>이 발생한다.</li>
<li>트랩이 발생하면 프로세스의 PCB를 살펴 참조의 유효성을 검사한다. 프로세스의 가상 주소 공간을 벗어난 참조를 하여 참조가 유효하지 않은 경우 프로세스는 종료된다.</li>
<li>빈 프레임을 찾는다.</li>
<li>디스크 입출력을 이용하여 페이지를 프레임에 적재한다.</li>
<li>디스크 입출력이 종료되면 프로세스의 내부 테이블과 페이지 테이블을 수정한다.</li>
<li>페이지 결함 트랩을 발생시킨 명령어를 다시 수행한다.</li>
</ol>
<p><strong>순수 요구 페이징</strong>은 프로세스가 처음 실행될 때 주기억 장치에 페이지가 전혀 없는 상태로 시작하는 방식을 의미한다. 따라서 초기에는 페이지 결함이 자주 발생한다.</p>
<p>한 명령어를 실행한 결과로 여러 페이지 결함이 발생할 수 있으나, 참조의 지역성<em>locality of reference</em> 원리로 인해 이러한 경우는 매우 드물다.</p>
<p>하드웨어는 다음과 같은 부분에서 요구 페이징을 지원한다.</p>
<ul>
<li>페이지 테이블에 대한 지원 : TLB, 유효 비트, 보호 비트</li>
<li>보조 기억 장치 : 디스크 일부분을 스왑 공간으로 사용</li>
</ul>
<p>일반적으로 페이지 결함을 일으킨 명령어를 다시 실행하는 것은 문제가 되지 않는다.</p>
<p>힌 명령어가 두 개 이상의 다른 페이지에 접근하는 경우 명령어를 다시 실행하는 것이 간단하지 않은데, 이를 해결하기 위한 해결책은 다음과 같다.</p>
<ul>
<li>명령어 수행에 필요한 모든 페이지를 미리 검사하여 이들을 주기억 장치에 적재한 후 명령어를 수행한다.</li>
<li>임시 레지스터를 이용하여 일시적으로 바꾼 위치의 기존 값을 보관하고, 페이지 결함이 발생하면 기존 값을 복원한 후 다시 명령어를 수행한다.</li>
</ul>
<h3 id="요구-페이징의-성능"><a href="#요구-페이징의-성능" class="headerlink" title="요구 페이징의 성능"></a>요구 페이징의 성능</h3><p>(페이지 결함이 일어날 확률) * (페이지 결함을 처리하는 데 소요되는 시간) + (1 - 페이지 결함이 일어날 확률) * (주기억 장치 접근 소요 시간)</p>
<p>페이지 결함의 처리는 다음의 요소로 구성된다.</p>
<ul>
<li>페이지 결함 인터럽트의 처리의 소요 시간은 마이크로초 단위를 갖는다.</li>
<li>디스크에 있는 페이지를 주기억 장치에 적재한다. 디스크 입출력에 소요되는 시간은 주기억 장치에 접근하는 시간과 비교했을 때 매우 크다.</li>
<li>디스크 입출력이 발생하므로 프로세스는 대기중 상태가 되며, CPU는 스케줄링 알고리즘에 따라 해당 프로세스를 스케줄링하여 중단된 프로세스를 재개한다.</li>
</ul>
<p>페이지 결함을 처리하는 전체 시간은 디스크 입출력 시간에 비례한다.</p>
<p>스왑 공간에 대한 입출력은 디스크 내의 다른 공간으로부터의 입출력보다 상대적으로 빠르므로, 프로그램을 실행할 때 모두 스왑 공간으로 옮긴 후 스왑 공간에서 페이징이 일어나도록 하면 성능을 향상시킬 수 있다.</p>
<h2 id="프로세스-생성"><a href="#프로세스-생성" class="headerlink" title="프로세스 생성"></a>프로세스 생성</h2><h3 id="Copy-on-Write"><a href="#Copy-on-Write" class="headerlink" title="Copy-on-Write"></a>Copy-on-Write</h3><p>프로그램을 처음 실행하면 디스크에 있는 실행 이미지를 이용하여 프로세스를 생성하며, fork 명령을 사용하여 자식 프로세스를 생성할 수 있다. 이 때 디스크 입출력은 필요 없다.</p>
<p>보통 자식 프로세스는 exec 명령을 통해 다른 프로그램을 실행하므로, 부모 프로세스의 주소 공간을 복사하는 것은 낭비다.</p>
<p>이 때 copy-on-write 기법을 사용하여, 변경하는 페이지만 복사되고 나머지는 부모 프로세스와 공유하도록 할 수 있다.</p>
<h3 id="기억장치-사상-파일"><a href="#기억장치-사상-파일" class="headerlink" title="기억장치-사상 파일"></a>기억장치-사상 파일</h3><p>디스크에 있는 파일에 접근할 때마다 디스크 입출력이 발생하므로, 파일에 처음 접근할 때 페이지 크기만큼의 데이터를 가상 기억 장치에 적재하고, 그 다음부터는 주기억 장치 접근을 통해 파일에 접근하는 방식이다.</p>
<h2 id="페이지-교체"><a href="#페이지-교체" class="headerlink" title="페이지 교체"></a>페이지 교체</h2><p>다중 프로그래밍의 정도를 높이면 프레임 공간이 부족할 수 있고, 주기억 장치의 모든 프레임을 사용자 프로세스에게 할당해줄 수 없다.</p>
<p>페이지 결함이 발생했을 때 페이지를 수용할 프레임이 없다면, 운영체제는 다음 중 한 가지 방법을 선택하여 이를 해결해야 한다.</p>
<ul>
<li>프로세스 종료</li>
<li>프로세스 스왑 아웃 : 프로세스의 모든 페이지를 디스크로 스왑 아웃하여 다중 프로그래밍의 정도를 줄인다.</li>
<li><strong>페이지 교체<em>page replacement</em></strong> : 적재되어 있는 기존 페이지를 새로운 페이지로 교체</li>
</ul>
<h3 id="기본-방법"><a href="#기본-방법" class="headerlink" title="기본 방법"></a>기본 방법</h3><p>페이지 결함이 발생할 때, 다음의 절차로 페이지 교체가 이루어진다.</p>
<ol>
<li>디스크에서 페이지의 위치를 찾는다.</li>
<li>빈 프레임을 찾는다. 빈 프레임이 있으면 그 곳에 페이지를 적재하고, 없으면 페이지 교체 알고리즘을 이용하여 희생 프레임을 선택한다. 희생 프레임에 있는 페이지를 디스크에 쓰고, 그 프레임에 새로운 페이지를 적재한다.</li>
<li>페이지 테이블과 프레임 테이블을 변경한다.</li>
<li>프로세스를 재개한다.</li>
</ol>
<p>빈 프레임이 없는 경우 항상 두 번의 디스크 입출력이 필요하며, <strong>변경 비트<em>modify bit, dirty bit</em></strong>를 이용하여 줄일 수 있다.</p>
<p>변경이 없는 페이지가 희생자로 선택되면 이를 디스크에 쓸 필요가 없으나, 디스크에 이 페이지의 복사본이 없다면 변경 여부에 상관 없이 디스크에 써야 한다.</p>
<p>실행 전용 페이지는 무조건 디스크로 다시 옮겨질 필요가 없다.</p>
<p>다음의 알고리즘이 필요하다.</p>
<ul>
<li><strong>프레임 할당 알고리즘<em>frame-allocation algorithm</em></strong> : 한 프로세스에게 할당할 프레임의 수를 결정</li>
<li><strong>페이지 교체 알고리즘<em>page-replacement algorithm</em></strong> : 빈 프레임이 없을 때 희생 프레임을 선택. 낮은 페이지 결함률을 제공할 수 있어야 한다.</li>
</ul>
<p>일련의 주기억 장치 참조에 대하여 페이지 결함 수를 계산하여 알고리즘을 평가한다.</p>
<p>페이지 결함 수를 계산하기 위해서는 프로세스에게 할당된 프레임의 수를 알아야 하며, 프레임 수가 많을 수록 결함 발생 수는 적어진다.</p>
<h3 id="FIFO-페이지-교체-알고리즘"><a href="#FIFO-페이지-교체-알고리즘" class="headerlink" title="FIFO 페이지 교체 알고리즘"></a>FIFO 페이지 교체 알고리즘</h3><p>First-In-First-Out</p>
<p>가장 오래 전에 들어온 페이지가 희생자로 선택된다.</p>
<p>프레임 수가 증가하면 페이지 결함 발생 수는 감소해야 정상이나, FIFO 알고리즘을 사용하는 경우 그 수치가 증가하는 경우가 있다.</p>
<h3 id="OPT-페이지-교체-알고리즘"><a href="#OPT-페이지-교체-알고리즘" class="headerlink" title="OPT 페이지 교체 알고리즘"></a>OPT 페이지 교체 알고리즘</h3><p>Optimal</p>
<p>가장 오랫동안 사용되지 않을 페이지가 희생자로 선택된다.</p>
<p>페이지 결함 수를 이 이상으로 줄일 수 없다.</p>
<p>미래의 참조를 예측하는 것이 어렵다는 것이 문제다.</p>
<h3 id="LRU-페이지-교체-알고리즘"><a href="#LRU-페이지-교체-알고리즘" class="headerlink" title="LRU 페이지 교체 알고리즘"></a>LRU 페이지 교체 알고리즘</h3><p>Least-Recently Used</p>
<p>가장 오래 전에 참조된 페이지가 희생자로 선택된다.</p>
<p>가장 널리 사용되는 기법이다.</p>
<p>카운터를 사용하여 구현할 수 있다. 각 페이지 테이블의 항에 카운터 필드를 추가하여 마지막으로 접근된 시간을 나타낸다. </p>
<p>이 방법을 사용하는 경우 교체가 필요할 때마다 테이블 전체를 검색해야 하며, 페이지가 접근될 때마다 페이지 테이블을 갱신해야 한다.</p>
<p>스택을 사용하여 구현할 수 있다. 스택의 가장 위에 가장 최근에 접근한 페이지를 유지하고, 가장 아래에 교체할 페이지를 유지한다. 스택 중간에 있는 페이지를 맨 위로 옮길 수 있어야 하므로 이중 연결 리스트를 이용하여 구현한다.</p>
<p>갱신 비용이 카운터보다 많이 소요되지만, 검색할 필요가 없어진다.</p>
<p>하드웨어의 지원이 반드시 필요하다. 소프트웨어로 테이블을 갱신하면 주기억 장치 접근마다 많은 시간이 소요된다.</p>
<h3 id="근접-LRU-페이지-교체-알고리즘"><a href="#근접-LRU-페이지-교체-알고리즘" class="headerlink" title="근접 LRU 페이지 교체 알고리즘"></a>근접 LRU 페이지 교체 알고리즘</h3><p>LRU를 제공하기 위한 충분한 하드웨어 지원이 없는 경우 사용한다.</p>
<p>대부분의 컴퓨터는 <strong>참조 비트<em>reference bit</em></strong>를 제공하며, 어떤 페이지가 참조되면 자동으로 해당 페이지 테이블을 갱신해준다. 이를 이용하여 LRU와 근접한 페이지 교체 알고리즘을 제공할 수 있다.</p>
<h4 id="추가-참조-비트-알고리즘"><a href="#추가-참조-비트-알고리즘" class="headerlink" title="추가 참조 비트 알고리즘"></a>추가 참조 비트 알고리즘</h4><p>각 페이지마다 참조 비트 외에 추가로 8비트를 두고, 주기적으로 오른쪽 쉬프트 연산을 수행하여, 지난 8주기 동안 각 페이지의 접근 여부를 유지하는 방법이다.</p>
<p><code>0000 0000</code>이라면 8주기 동안 한 번도 접근되지 않은 페이지를 나타내며, <code>1100 0100</code>인 페이지는 <code>0111 0111</code>인 페이지보다 최근에 접근되었음을 의미한다.</p>
<p>이를 유지하는 비트의 수는 다양할 수 있으며, 극단적으로 그 수를 0까지 줄일 수 있다.</p>
<h4 id="기회를-한번-더-주는-알고리즘"><a href="#기회를-한번-더-주는-알고리즘" class="headerlink" title="기회를 한번 더 주는 알고리즘"></a>기회를 한번 더 주는 알고리즘</h4><p>참조 비트만 사용한다. 처음에 페이지에 접근하면 참조 비트가 1이 되고, 주기마다 이것을 다시 0으로 바꾸어 준다.</p>
<p>순환 버퍼를 이용하여 구현할 수 있다.</p>
<p>교체할 페이지는 순환 버퍼에서 비트 값이 0인 것이 선택되며, 이를 찾을 때까지 비트 값이 1인 것을 0으로 바꾼다.</p>
<p>새 페이지는 순환 버퍼에 교체되는 페이지 위치에 삽입된다.</p>
<p>순환 버퍼에 있는 모든 페이지의 값이 1이면 이 알고리즘은 FIFO와 같아지게 된다.</p>
<h4 id="확장된-클럭-알고리즘"><a href="#확장된-클럭-알고리즘" class="headerlink" title="확장된 클럭 알고리즘"></a>확장된 클럭 알고리즘</h4><p>참조 비트와 변경 비트를 함께 사용한다. <code>(참조 비트, 변경 비트)</code></p>
<ul>
<li>1분류 (0, 0) : 최근에 사용되지 않고, 변경되지 않은 페이지</li>
<li>2분류 (0, 1) : 최근에 사용되지 않았으나 변경된 페이지. 교체시 디스크에 써야 한다.</li>
<li>3분류 (1, 0) : 최근에 사용되었으나 변경되지 않은 페이지</li>
<li>4분류 (1, 1) : 최근에 사용되고 변경된 페이지</li>
</ul>
<p>낮은 분류에 속한 페이지를 먼저 교체한다. (사용되지 않은 페이지를 우선적으로 교체한다.)</p>
<p>검색 시간이 길어진다.</p>
<h3 id="계수-기반-페이지-교체-알고리즘"><a href="#계수-기반-페이지-교체-알고리즘" class="headerlink" title="계수 기반 페이지 교체 알고리즘"></a>계수 기반 페이지 교체 알고리즘</h3><p>LFU : Least-Frequently-Used</p>
<p>참조된 횟수를 기반으로 한다. 참조가 가장 적은 페이지를 교체한다.</p>
<p>초기에 많이 사용되었으나 더 이상 사용되지 않은 페이지는 교체되지 않을 수 있으며, 처음으로 교체되어 들어온 페이지는 바로 교체될 수 있다.</p>
<p>주기적으로 참조 횟수를 감소시켜 전자의 문제를 극복할 수 있다.</p>
<p>MFU : Most-Frequently-Used</p>
<p>참조가 가장 많은 페이지를 교체한다. 참조가 적은 것일수록 최근에 들어온 것으로 간주한다.</p>
<p>두 방법 모두 거의 사용되지 않는다.</p>
<h3 id="페이지-버퍼링-알고리즘"><a href="#페이지-버퍼링-알고리즘" class="headerlink" title="페이지 버퍼링 알고리즘"></a>페이지 버퍼링 알고리즘</h3><p>고정된 수의 빈 프레임을 유지하여, 새로운 페이지를 희생자 프레임에 적재하지 않고 우선 빈 프레임 풀에 속한 프레임에 적재한다.</p>
<p>희생자 프레임이 디스크에 쓰여지면 이 프레임을 빈 프레임 풀에 추가한다.</p>
<p>빈 프레임 풀에 속한 각 프레임에 어떤 페이지가 적재되어 있는지 유지하여 페이지 교체 때 이를 활용할 수 있다.</p>
<p>변경된 페이지 목록을 유지하고, 페이징 장치가 유휴 상태이면 변경 페이지를 하나 선택하여 디스크에 쓰고 변경 비트를 재설정한다.</p>
<p>교체할 페이지가 항상 변경되지 않은 깨끗한 페이지일 확률을 높여준다.</p>
<h2 id="프레임-할당"><a href="#프레임-할당" class="headerlink" title="프레임 할당"></a>프레임 할당</h2><p>운영체제가 필요로 하는 만큼을 제외한 나머지 프레임은 모두 사용자 프로세스에게 할당된다. 이 중 일부는 항상 빈 프레임이 되게 할 수 있다.</p>
<h3 id="최저-프레임-수"><a href="#최저-프레임-수" class="headerlink" title="최저 프레임 수"></a>최저 프레임 수</h3><p>프로세스가 필요로 하는 최소 프레임 수 이상을 프로세스에게 할당해 주어야 한다.</p>
<p>최저 프레임 수는 명령어 집합 구조<em>instruction set architecture</em>가 결정한다. 하나의 명령어가 참조할 수 있는 모든 페이지를 수용할 수 있을 만큼의 프레임은 최소한 제공되어야 한다.</p>
<p>명령어가 위치한 프레임과, 명령어가 참조하는 페이지는 동시에 수용될 수 있어야 한다. 페이지 결함이 발생하면 그 페이지를 주기억 장치에 적재한 후 명령어를 다시 실행할 수 있어야 하기 때문이다.</p>
<h3 id="할당-알고리즘"><a href="#할당-알고리즘" class="headerlink" title="할당 알고리즘"></a>할당 알고리즘</h3><p>프레임의 개수가 n개이고, 프로세스의 개수가 m개일 때,</p>
<p><strong>균등 할당<em>equal allocation</em> 알고리즘</strong>은 각 프로세스에게 n / m 개의 프레임을 할당한다.</p>
<p><strong>비례 할당<em>proportional allocation</em> 알고리즘</strong>은 각 프로세스의 크기에 비례하여 할당한다.</p>
<p><strong>우선순위 기반 알고리즘</strong>은 각 프로세스의 우선순위에 비례하여 프레임을 할당한다.</p>
<h3 id="광역-및-지역-할당"><a href="#광역-및-지역-할당" class="headerlink" title="광역 및 지역 할당"></a>광역 및 지역 할당</h3><p>다중 프로세스가 존재할 때, 페이지 교체 알고리즘은 다음과 같이 분류된다.</p>
<ul>
<li><strong>광역 교체 알고리즘<em>global replacement algorithm</em></strong> : 다른 프로세스의 페이지가 희생자로 선택될 수 있음</li>
<li><strong>지역 교체 알고리즘<em>local replacement algorithm</em></strong> : 자신의 프로세스에 있는 페이지만 희생자로 선택될 수 있음</li>
</ul>
<p>광역 교체는 우선순위가 높은 프로세스에게 우선순위가 낮은 프로세스를 희생시켜 할당된 프레임 수를 늘려줄 수 있으나, 프로세스 성능이 외부 상황에 의해 변화할 수 있다.</p>
<p>현재는 광역 교체 알고리즘을 많이 사용한다.</p>
<h2 id="스레싱"><a href="#스레싱" class="headerlink" title="스레싱"></a>스레싱</h2><p>Thrashing. 계속하여 페이지 결함이 발생하는 현상을 말한다.</p>
<p>실행 시간보다 페이지 결함을 처리하는 시간이 많아지면 스레싱이 발생하였다고 말한다.</p>
<p>프로세스에 할당된 프레임 수가 필요한 최소의 프레임 수 이하로 내려가면 스레싱이 발생한다.</p>
<h3 id="스레싱의-원인"><a href="#스레싱의-원인" class="headerlink" title="스레싱의 원인"></a>스레싱의 원인</h3><p>다중 프로그래밍의 정도가 낮으면 CPU 사용 효율이 떨어지며, 이를 높이기 위해 프로세스의 수를 과도하게 늘리면 스레싱이 발생하여 오히려 사용 효율이 떨어지게 된다.</p>
<p>지역 교체 알고리즘을 사용하면 스레싱 효과를 줄일 수 있다. 하나의 프로세스에서의 스레싱이 다른 프로세스에 영향을 주지 않기 때문이다.</p>
<p>하지만 스레싱이 발생한 프로세스는 대부분의 시간을 페이징 장치의 큐에서 보내게 되므로 다른 프로세스도 기다리는 시간이 길어지게 된다.</p>
<p>프로세스에게 필요한 만큼의 프레임을 할당해줄 수 있어야 스레싱을 예방할 수 있으나, 필요로 하는 프레임 수를 알기 어렵다.</p>
<p><strong>지역성 모델<em>locality model</em></strong> : 프로세스는 실행되는 동안 한 지역(현재 활동적으로 사용하고 있는 페이지 집합)에서 다른 지역으로 이동하는데, 현재 프로세스의 지역을 수용할 수 있는 만큼의 프레임을 할당해 주면 스레싱은 발생하지 않는다.</p>
<h3 id="작업-집합-모델"><a href="#작업-집합-모델" class="headerlink" title="작업 집합 모델"></a>작업 집합 모델</h3><p>Working-Set Model. 지역성 가정에 기반한 모델이다.</p>
<p>가장 최근에 참조한 페이지 집합을 말한다.</p>
<p>작업 집합이 작으면 현재 지역을 충분히 나타내지 못하며, 크면 다른 지역과 중첩될 수 있다.</p>
<p>운영체제는 각 프로세스의 작업 집합을 감시하여 각 프로세스의 현재 작업 집합을 수용할 수 있는 충분한 수의 프레임을 각 프로세스에게 할당한다.</p>
<p>새 프로세스를 수용할 만큼의 빈 프레임이 생기면 새 프로세스를 실행하며, 각 프로세스의 작업 집합 크기가 사용 가능한 프레임 수를 초과하면 하나의 프로세스를 일시 중단한다.</p>
<h3 id="페이지-결함-빈도"><a href="#페이지-결함-빈도" class="headerlink" title="페이지 결함 빈도"></a>페이지 결함 빈도</h3><p>페이지 결함 빈도에 따라 할당되는 프레임 수를 조절한다.</p>
<p>페이지 결함률의 상한과 하한을 정하여, 결함률이 상한보다 높으면 프레임을 추가로 할당하고, 하한보다 낮으면 프레임을 제거한다.</p>
<p>페이지 결함률이 상한을 넘었으나 추가로 할당해 줄 빈 프레임이 없으면 프로세스를 일시 중단한다.</p>
<h2 id="다른-고려"><a href="#다른-고려" class="headerlink" title="다른 고려"></a>다른 고려</h2><h3 id="선페이징"><a href="#선페이징" class="headerlink" title="선페이징"></a>선페이징</h3><p>Prepaging.</p>
<p>순수 요구 페이징의 문제는, 초기에 많은 페이지 결함이 발생한다는 것이다. 또한 스왑 아웃된 프로세스를 다시 실행할 때에도 같은 현상이 발생한다.</p>
<p>선페이징 방식을 사용하여 초기 높은 페이지 결함률을 줄일 수 있다.</p>
<p>작업 집합 모델을 사용하는 경우, 스왑 아웃할 때 작업 집합 모델에 포함된 페이지 목록을 보관하였다가 다시 스왑 인 될 때 그 페이지 목록을 모두 적재한 후 프로세스를 재개한다.</p>
<p>선페이징의 비용이 페이지 결함을 처리하는 비용보다 적어야 효과가 있다.</p>
<h3 id="페이지의-크기"><a href="#페이지의-크기" class="headerlink" title="페이지의 크기"></a>페이지의 크기</h3><p>페이지 크기가 클수록 페이지 테이블의 크기는 작아지나, 마지막 페이지에 존재하는 내부 단편화가 크다.</p>
<p>입출력 시간을 최소화하려면 페이지 크기가 큰 것이 좋다.</p>
<p>입출력의 전체 크기는 페이지 크기가 작은 것이 좋다. 페이지 크기가 작을 수록 지역성이 향상되어 불필요한 것이 주기억 장치에 적재될 확률이 낮아지기 때문이다.</p>
<p>페이지 결함률은 페이지 크기가 클수록 낮다. 페이지 결함이 낮을수록 페이지 결함을 처리하는 오버헤드가 적어진다.</p>
<p>최근에는 페이지 크기를 크게 하여 사용한다.</p>
<h3 id="TLB-범위"><a href="#TLB-범위" class="headerlink" title="TLB 범위"></a>TLB 범위</h3><blockquote>
<p>TLB : 페이지 테이블을 구현하기 위한 하드웨어 지원. 캐시 역할</p>
</blockquote>
<p>TLB 적중률<em>hit ratio</em>은, 페이지 테이블 대신 TLB에서 가상 주소 번역이 이루어지는 비율을 말한다.</p>
<p>TLB 범위<em>reach</em>는 TLB를 통해 접근 가능한 주기억 장치 공간을 말한다.</p>
<p>최소한 프로세스의 작업 집합은 TLB에 저장되어 있어야 한다.</p>
<p>페이지 크기를 늘리면 TLB 범위도 넓어지지만 내부 단편화가 증가할 수 있다.</p>
<h3 id="프로그램의-구조"><a href="#프로그램의-구조" class="headerlink" title="프로그램의 구조"></a>프로그램의 구조</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// (1)</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">128</span>; ++i) &#123;</span><br><span class="line">  <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">128</span>; ++j) &#123;</span><br><span class="line">    a[j][i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (2)</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">128</span>; ++i) &#123;</span><br><span class="line">  <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">128</span>; ++j) &#123;</span><br><span class="line">    a[i][j] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위의 코드에서, (1)은 (2)보다 효율적이지 않다. 배열은 행 중심이므로 (1)의 경우에 페이지 결함이 더 많이 발생할 수 있기 때문이다.</p>
<p>예를 들어 스택의 경우 항상 맨 위에 있는 스택 요소를 이용하여 조작하므로 페이징에 효율적이지만, 해시 테이블의 경우 접근 위치가 널리 퍼져 있으므로 페이징에 효율적이지 않다.</p>
<p>페이징에 유리한 코드를 작성하여 성능을 높이는 것이 좋다.</p>
<h3 id="페이지-잠금"><a href="#페이지-잠금" class="headerlink" title="페이지 잠금"></a>페이지 잠금</h3><p>요구 페이징을 사용할 때, 어떤 페이지들은 교체될 수 없게 해야 하는 경우가 있다. 예를 들어 입출력을 요청한 프로세스가 입출력할 내용을 버퍼에 옮기고 입출력 대기 큐로 이동한 후, 광역 교체 알고리즘에 의해 큐로 이동한 프로세스의 버퍼 페이지가 교체되는 경우, 엉뚱한 데이터가 입출력될 수 있다.</p>
<p>이를 해결하기 위해 입출력은 항상 시스템에게 할당된 주기억 장치 영역에서 이루어지도록 할 수 있으나 추가 복사가 필요하게 된다.</p>
<p>각 프레임마다 <strong>잠금 비트<em>lock bit</em></strong>를 연관시켜 희생자로 선택될 수 없게 할수도 있다.</p>
<p>입출력에 사용될 버퍼나 운영체제 커널에게 할당된 페이지는 잠금 비트를 설정하여 교체될 수 없도록 한다.</p>
<p>잠금 기법은 주의 깊게 사용되어야 한다. 사용자 페이지는 잠금 후 적절할 때에 잠금 해제되어 사용할 수 있는 프레임 수를 일정 수준으로 유지할 수 있게 해야 한다.</p>

  </div>
</article>

    <div class="blog-post-comments">
        <div id="disqus_thread">
            <noscript>Please enable JavaScript to view the comments.</noscript>
        </div>
    </div>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Posts</a></li>
         
          <li><a href="/tags/">Tag</a></li>
         
          <li><a href="/categories/">Category</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#가상기억장치"><span class="toc-number">1.</span> <span class="toc-text">가상기억장치</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#배경"><span class="toc-number">1.1.</span> <span class="toc-text">배경</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#요구-페이징"><span class="toc-number">1.2.</span> <span class="toc-text">요구 페이징</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#기본-개념"><span class="toc-number">1.2.1.</span> <span class="toc-text">기본 개념</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#요구-페이징의-성능"><span class="toc-number">1.2.2.</span> <span class="toc-text">요구 페이징의 성능</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#프로세스-생성"><span class="toc-number">1.3.</span> <span class="toc-text">프로세스 생성</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Copy-on-Write"><span class="toc-number">1.3.1.</span> <span class="toc-text">Copy-on-Write</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#기억장치-사상-파일"><span class="toc-number">1.3.2.</span> <span class="toc-text">기억장치-사상 파일</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#페이지-교체"><span class="toc-number">1.4.</span> <span class="toc-text">페이지 교체</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#기본-방법"><span class="toc-number">1.4.1.</span> <span class="toc-text">기본 방법</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FIFO-페이지-교체-알고리즘"><span class="toc-number">1.4.2.</span> <span class="toc-text">FIFO 페이지 교체 알고리즘</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OPT-페이지-교체-알고리즘"><span class="toc-number">1.4.3.</span> <span class="toc-text">OPT 페이지 교체 알고리즘</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LRU-페이지-교체-알고리즘"><span class="toc-number">1.4.4.</span> <span class="toc-text">LRU 페이지 교체 알고리즘</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#근접-LRU-페이지-교체-알고리즘"><span class="toc-number">1.4.5.</span> <span class="toc-text">근접 LRU 페이지 교체 알고리즘</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#추가-참조-비트-알고리즘"><span class="toc-number">1.4.5.1.</span> <span class="toc-text">추가 참조 비트 알고리즘</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#기회를-한번-더-주는-알고리즘"><span class="toc-number">1.4.5.2.</span> <span class="toc-text">기회를 한번 더 주는 알고리즘</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#확장된-클럭-알고리즘"><span class="toc-number">1.4.5.3.</span> <span class="toc-text">확장된 클럭 알고리즘</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#계수-기반-페이지-교체-알고리즘"><span class="toc-number">1.4.6.</span> <span class="toc-text">계수 기반 페이지 교체 알고리즘</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#페이지-버퍼링-알고리즘"><span class="toc-number">1.4.7.</span> <span class="toc-text">페이지 버퍼링 알고리즘</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#프레임-할당"><span class="toc-number">1.5.</span> <span class="toc-text">프레임 할당</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#최저-프레임-수"><span class="toc-number">1.5.1.</span> <span class="toc-text">최저 프레임 수</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#할당-알고리즘"><span class="toc-number">1.5.2.</span> <span class="toc-text">할당 알고리즘</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#광역-및-지역-할당"><span class="toc-number">1.5.3.</span> <span class="toc-text">광역 및 지역 할당</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#스레싱"><span class="toc-number">1.6.</span> <span class="toc-text">스레싱</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#스레싱의-원인"><span class="toc-number">1.6.1.</span> <span class="toc-text">스레싱의 원인</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#작업-집합-모델"><span class="toc-number">1.6.2.</span> <span class="toc-text">작업 집합 모델</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#페이지-결함-빈도"><span class="toc-number">1.6.3.</span> <span class="toc-text">페이지 결함 빈도</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#다른-고려"><span class="toc-number">1.7.</span> <span class="toc-text">다른 고려</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#선페이징"><span class="toc-number">1.7.1.</span> <span class="toc-text">선페이징</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#페이지의-크기"><span class="toc-number">1.7.2.</span> <span class="toc-text">페이지의 크기</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TLB-범위"><span class="toc-number">1.7.3.</span> <span class="toc-text">TLB 범위</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#프로그램의-구조"><span class="toc-number">1.7.4.</span> <span class="toc-text">프로그램의 구조</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#페이지-잠금"><span class="toc-number">1.7.5.</span> <span class="toc-text">페이지 잠금</span></a></li></ol></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://presto95.github.io/2020/01/18/os-lecture-note-virtual-memory/" target="_blank" rel="noopener"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://presto95.github.io/2020/01/18/os-lecture-note-virtual-memory/&text=운영체제 강의노트 정리 - 가상기억장치" target="_blank" rel="noopener"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://presto95.github.io/2020/01/18/os-lecture-note-virtual-memory/&title=운영체제 강의노트 정리 - 가상기억장치" target="_blank" rel="noopener"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://presto95.github.io/2020/01/18/os-lecture-note-virtual-memory/&is_video=false&description=운영체제 강의노트 정리 - 가상기억장치" target="_blank" rel="noopener"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=운영체제 강의노트 정리 - 가상기억장치&body=Check out this article: http://presto95.github.io/2020/01/18/os-lecture-note-virtual-memory/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://presto95.github.io/2020/01/18/os-lecture-note-virtual-memory/&title=운영체제 강의노트 정리 - 가상기억장치" target="_blank" rel="noopener"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://presto95.github.io/2020/01/18/os-lecture-note-virtual-memory/&title=운영체제 강의노트 정리 - 가상기억장치" target="_blank" rel="noopener"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://presto95.github.io/2020/01/18/os-lecture-note-virtual-memory/&title=운영체제 강의노트 정리 - 가상기억장치" target="_blank" rel="noopener"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://presto95.github.io/2020/01/18/os-lecture-note-virtual-memory/&title=운영체제 강의노트 정리 - 가상기억장치" target="_blank" rel="noopener"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://presto95.github.io/2020/01/18/os-lecture-note-virtual-memory/&name=운영체제 강의노트 정리 - 가상기억장치&description=" target="_blank" rel="noopener"><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://news.ycombinator.com/submitlink?u=http://presto95.github.io/2020/01/18/os-lecture-note-virtual-memory/&t=운영체제 강의노트 정리 - 가상기억장치" target="_blank" rel="noopener"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2020 Presto
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Posts</a></li>
         
          <li><a href="/tags/">Tag</a></li>
         
          <li><a href="/categories/">Category</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">


<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">


    <!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>

<!-- clipboard -->

  
<script src="/lib/clipboard/clipboard.min.js"></script>

  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Disqus Comments -->

    <script type="text/javascript">
        var disqus_shortname = 'presto95';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>


</body>
</html>
