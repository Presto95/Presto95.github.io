<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="스위프트 성능 파헤치기2016년 Let’Swift의 Swift 성능 이해하기: Value 타입, Protocol과 스위프트의 성능 최적화 세션 내용을 공유한다. 메모리나 저수준 코드의 형태로 보여줄 수 있다면 보여주어 이해를 최대한 돕는다. Value Semantics &amp; Reference SemanticsValue SemanticsCopy-by-V">
<meta property="og:type" content="article">
<meta property="og:title" content="Swift 성능 이해하기">
<meta property="og:url" content="http://presto95.github.io/2020/01/18/understanding-swift-performance/index.html">
<meta property="og:site_name" content="Presto">
<meta property="og:description" content="스위프트 성능 파헤치기2016년 Let’Swift의 Swift 성능 이해하기: Value 타입, Protocol과 스위프트의 성능 최적화 세션 내용을 공유한다. 메모리나 저수준 코드의 형태로 보여줄 수 있다면 보여주어 이해를 최대한 돕는다. Value Semantics &amp; Reference SemanticsValue SemanticsCopy-by-V">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-01-17T15:27:43.000Z">
<meta property="article:modified_time" content="2020-01-17T15:28:06.344Z">
<meta property="article:author" content="Presto">
<meta property="article:tag" content="swift">
<meta name="twitter:card" content="summary">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>Swift 성능 이해하기</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/css/rtl.css">

    
    <!-- rss -->
    
    
<meta name="generator" content="Hexo 4.2.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Posts</a></li>
         
          <li><a href="/tags/">Tag</a></li>
         
          <li><a href="/categories/">Category</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2020/01/18/whole-module-optimization/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2020/01/18/os-lecture-note-mass-storage-structure/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://presto95.github.io/2020/01/18/understanding-swift-performance/" target="_blank" rel="noopener"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://presto95.github.io/2020/01/18/understanding-swift-performance/&text=Swift 성능 이해하기" target="_blank" rel="noopener"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://presto95.github.io/2020/01/18/understanding-swift-performance/&title=Swift 성능 이해하기" target="_blank" rel="noopener"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://presto95.github.io/2020/01/18/understanding-swift-performance/&is_video=false&description=Swift 성능 이해하기" target="_blank" rel="noopener"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Swift 성능 이해하기&body=Check out this article: http://presto95.github.io/2020/01/18/understanding-swift-performance/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://presto95.github.io/2020/01/18/understanding-swift-performance/&title=Swift 성능 이해하기" target="_blank" rel="noopener"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://presto95.github.io/2020/01/18/understanding-swift-performance/&title=Swift 성능 이해하기" target="_blank" rel="noopener"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://presto95.github.io/2020/01/18/understanding-swift-performance/&title=Swift 성능 이해하기" target="_blank" rel="noopener"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://presto95.github.io/2020/01/18/understanding-swift-performance/&title=Swift 성능 이해하기" target="_blank" rel="noopener"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://presto95.github.io/2020/01/18/understanding-swift-performance/&name=Swift 성능 이해하기&description=" target="_blank" rel="noopener"><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://news.ycombinator.com/submitlink?u=http://presto95.github.io/2020/01/18/understanding-swift-performance/&t=Swift 성능 이해하기" target="_blank" rel="noopener"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#스위프트-성능-파헤치기"><span class="toc-number">1.</span> <span class="toc-text">스위프트 성능 파헤치기</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Value-Semantics-amp-Reference-Semantics"><span class="toc-number">1.1.</span> <span class="toc-text">Value Semantics &amp; Reference Semantics</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Value-Semantics"><span class="toc-number">1.1.1.</span> <span class="toc-text">Value Semantics</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Value-Type의-특징"><span class="toc-number">1.1.2.</span> <span class="toc-text">Value Type의 특징</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#실험"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">실험</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#구조체에-Value-Type-프로퍼티가-존재할-때의-동작"><span class="toc-number">1.1.2.1.1.</span> <span class="toc-text">구조체에 Value Type 프로퍼티가 존재할 때의 동작</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#클래스에-Value-Type-프로퍼티가-존재할-때의-동작"><span class="toc-number">1.1.2.1.2.</span> <span class="toc-text">클래스에 Value Type 프로퍼티가 존재할 때의 동작</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Value-Semantics-‘값’에-의해-구분된다"><span class="toc-number">1.1.3.</span> <span class="toc-text">Value Semantics : ‘값’에 의해 구분된다</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Value-Type과-Thread"><span class="toc-number">1.1.4.</span> <span class="toc-text">Value Type과 Thread</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#복사-시-성능-문제"><span class="toc-number">1.1.5.</span> <span class="toc-text">복사 시 성능 문제?</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#실험-1"><span class="toc-number">1.1.5.1.</span> <span class="toc-text">실험</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#정해진-시간은-무엇을-의미하는-것일까"><span class="toc-number">1.1.5.1.1.</span> <span class="toc-text">정해진 시간은 무엇을 의미하는 것일까?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Array의-요소가-힙에-저장된다고"><span class="toc-number">1.1.5.1.2.</span> <span class="toc-text">Array의 요소가 힙에 저장된다고?</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reference-Type을-Immutable하게-만들면-되지-않는가"><span class="toc-number">1.1.6.</span> <span class="toc-text">Reference Type을 Immutable하게 만들면 되지 않는가?</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Immutable한-설계가-어울리지-않는-경우"><span class="toc-number">1.1.6.1.</span> <span class="toc-text">Immutable한 설계가 어울리지 않는 경우</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Immutable-객체를-갱신하기-위해-매번-새로운-객체를-만들고-할당하는-경우"><span class="toc-number">1.1.6.1.1.</span> <span class="toc-text">Immutable 객체를 갱신하기 위해 매번 새로운 객체를 만들고 할당하는 경우</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#API가-이상해지는-경우"><span class="toc-number">1.1.6.1.2.</span> <span class="toc-text">API가 이상해지는 경우</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#그래도-클래스는-중요하다"><span class="toc-number">1.1.7.</span> <span class="toc-text">그래도 클래스는 중요하다.</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#성능을-위해-고려할-것들"><span class="toc-number">1.2.</span> <span class="toc-text">성능을 위해 고려할 것들</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#메모리-할당"><span class="toc-number">1.2.1.</span> <span class="toc-text">메모리 할당</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#힙-할당-문제"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">힙 할당 문제</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#힙-할당-줄이기"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">힙 할당 줄이기</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#참조-카운팅-발생-여부"><span class="toc-number">1.2.2.</span> <span class="toc-text">참조 카운팅 발생 여부</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#참조-카운팅의-문제"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">참조 카운팅의 문제</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#실험-2"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">실험</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#참조-카운팅-직접-확인"><span class="toc-number">1.2.2.2.1.</span> <span class="toc-text">참조 카운팅 직접 확인</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#메소드-디스패치"><span class="toc-number">1.2.3.</span> <span class="toc-text">메소드 디스패치</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#정적-메소드-디스패치"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">정적 메소드 디스패치</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#메소드-인라이닝"><span class="toc-number">1.2.3.1.1.</span> <span class="toc-text">메소드 인라이닝</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#동적-메소드-디스패치"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">동적 메소드 디스패치</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#동적-메소드-디스패치의-문제"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">동적 메소드 디스패치의 문제</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Objective-C의-메소드-디스패치"><span class="toc-number">1.2.3.4.</span> <span class="toc-text">Objective-C의 메소드 디스패치</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#정적-디스패치로-강제하기"><span class="toc-number">1.2.3.5.</span> <span class="toc-text">정적 디스패치로 강제하기</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#실험-3"><span class="toc-number">1.2.3.6.</span> <span class="toc-text">실험</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#final-class-vs-class"><span class="toc-number">1.2.3.6.1.</span> <span class="toc-text">final class vs. class</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#final-class"><span class="toc-number">1.2.3.6.1.1.</span> <span class="toc-text">final class</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#class"><span class="toc-number">1.2.3.6.1.2.</span> <span class="toc-text">class</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#final-method-vs-normal-method"><span class="toc-number">1.2.3.6.2.</span> <span class="toc-text">final method vs. normal method</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#final-method"><span class="toc-number">1.2.3.6.2.1.</span> <span class="toc-text">final method</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#normal-method"><span class="toc-number">1.2.3.6.2.2.</span> <span class="toc-text">normal method</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#정리"><span class="toc-number">1.2.4.</span> <span class="toc-text">정리</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#스위프트의-추상화-기법들의-성능"><span class="toc-number">1.3.</span> <span class="toc-text">스위프트의 추상화 기법들의 성능</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Class"><span class="toc-number">1.3.1.</span> <span class="toc-text">Class</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Class-1"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">Class</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Final-Class"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">Final Class</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Struct"><span class="toc-number">1.3.2.</span> <span class="toc-text">Struct</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#참조-타입을-갖지-않는-Struct"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">참조 타입을 갖지 않는 Struct</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#참조-타입을-갖는-Struct"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">참조 타입을 갖는 Struct</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#참조-타입을-갖는-Struct가-참조-타입을-적게-갖도록-리팩토링하기"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">참조 타입을 갖는 Struct가 참조 타입을 적게 갖도록 리팩토링하기</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Protocol-Type"><span class="toc-number">1.3.3.</span> <span class="toc-text">Protocol Type</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Protocol"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">Protocol</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Protocol을-이용한-Value-Type-다형성"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">Protocol을 이용한 Value Type 다형성</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#프로토콜-타입을-사용할-때의-의문"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">프로토콜 타입을 사용할 때의 의문</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Existential-Container-정리"><span class="toc-number">1.3.3.4.</span> <span class="toc-text">Existential Container 정리</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#작은-사이즈-3워드-이하-의-Protocol-Type"><span class="toc-number">1.3.3.5.</span> <span class="toc-text">작은 사이즈(3워드 이하)의 Protocol Type</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#큰-사이즈-3워드-초과-의-Protocol-Type"><span class="toc-number">1.3.3.6.</span> <span class="toc-text">큰 사이즈(3워드 초과)의 Protocol Type</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Indirect-Storage-사용하여-개선한-큰-사이즈-Protocol-Type"><span class="toc-number">1.3.3.7.</span> <span class="toc-text">Indirect Storage 사용하여 개선한 큰 사이즈 Protocol Type</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#실험-4"><span class="toc-number">1.3.3.8.</span> <span class="toc-text">실험</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#프로토콜-타입일-때와-해당-타입일-경우의-차이는"><span class="toc-number">1.3.3.8.1.</span> <span class="toc-text">프로토콜 타입일 때와 해당 타입일 경우의 차이는?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3워드-초과-이하-차이로-인한-값-저장-동작-변화"><span class="toc-number">1.3.3.8.2.</span> <span class="toc-text">3워드 초과 &#x2F; 이하 차이로 인한 값 저장 동작 변화</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3워드-초과-이하-차이로-인한-Copy-동작-변화"><span class="toc-number">1.3.3.8.3.</span> <span class="toc-text">3워드 초과 &#x2F; 이하 차이로 인한 Copy 동작 변화</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#3워드-이하"><span class="toc-number">1.3.3.8.3.1.</span> <span class="toc-text">3워드 이하</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3워드-초과"><span class="toc-number">1.3.3.8.3.2.</span> <span class="toc-text">3워드 초과</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#VWT와-PWT는-힙에-위치하는가"><span class="toc-number">1.3.3.8.4.</span> <span class="toc-text">VWT와 PWT는 힙에 위치하는가?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Copy-on-Write가-발생하는가"><span class="toc-number">1.3.3.8.5.</span> <span class="toc-text">Copy-on-Write가 발생하는가?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#큰-크기의-Protocol-Type-vs-Indirect-Storage"><span class="toc-number">1.3.3.8.6.</span> <span class="toc-text">큰 크기의 Protocol Type vs. Indirect Storage</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Generic-Type"><span class="toc-number">1.3.4.</span> <span class="toc-text">Generic Type</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#실험-5"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">실험</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#정적-다형성이-구현된-것을-확인해볼-수-있을까"><span class="toc-number">1.3.4.1.1.</span> <span class="toc-text">정적 다형성이 구현된 것을 확인해볼 수 있을까?</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#특수화되지-않은-Generics-작은-크기의-Protocol-Type"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">특수화되지 않은 Generics (작은 크기의 Protocol Type)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#특수화되지-않은-Generics-큰-크기의-Protocol-Type"><span class="toc-number">1.3.4.3.</span> <span class="toc-text">특수화되지 않은 Generics (큰 크기의 Protocol Type)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#특수화된-Generic-Type-Struct"><span class="toc-number">1.3.4.4.</span> <span class="toc-text">특수화된 Generic Type (Struct)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#특수화된-Generic-Type-Class"><span class="toc-number">1.3.4.5.</span> <span class="toc-text">특수화된 Generic Type (Class)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#정리-1"><span class="toc-number">1.3.4.6.</span> <span class="toc-text">정리</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#마무리"><span class="toc-number">1.4.</span> <span class="toc-text">마무리</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#추상화-기법의-선택"><span class="toc-number">1.4.1.</span> <span class="toc-text">추상화 기법의 선택</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#고려할-수-있는-성능-최적화-기법들"><span class="toc-number">1.4.2.</span> <span class="toc-text">고려할 수 있는 성능 최적화 기법들</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#마무리-1"><span class="toc-number">1.4.3.</span> <span class="toc-text">마무리</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#더-알아볼-것들"><span class="toc-number">1.5.</span> <span class="toc-text">더 알아볼 것들</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Swift의-String"><span class="toc-number">1.5.1.</span> <span class="toc-text">Swift의 String</span></a></li></ol></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        Swift 성능 이해하기
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Presto</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2020-01-17T15:27:43.000Z" itemprop="datePublished">2020-01-18</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        <a class="category-link" href="/categories/Swift/">Swift</a>
    </div>


      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/tags/swift/" rel="tag">swift</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h1 id="스위프트-성능-파헤치기"><a href="#스위프트-성능-파헤치기" class="headerlink" title="스위프트 성능 파헤치기"></a>스위프트 성능 파헤치기</h1><p>2016년 Let’Swift의 <a href="https://academy.realm.io/kr/posts/letswift-swift-performance/" target="_blank" rel="noopener">Swift 성능 이해하기: Value 타입, Protocol과 스위프트의 성능 최적화</a> 세션 내용을 공유한다.</p>
<p>메모리나 저수준 코드의 형태로 보여줄 수 있다면 보여주어 이해를 최대한 돕는다.</p>
<h2 id="Value-Semantics-amp-Reference-Semantics"><a href="#Value-Semantics-amp-Reference-Semantics" class="headerlink" title="Value Semantics &amp; Reference Semantics"></a>Value Semantics &amp; Reference Semantics</h2><h3 id="Value-Semantics"><a href="#Value-Semantics" class="headerlink" title="Value Semantics"></a>Value Semantics</h3><p>Copy-by-Value. 인스턴스가 할당된 메모리의 주소와 관련 있는 Identity가 아닌, 값 자체에만 의미를 둔다.</p>
<p>값이 넘어갈 때 값을 복사하여 넘긴다.</p>
<p>Swift는 Objective-C에는 없는 Struct, Enum, Tuple 등의 Value Type이 있다.</p>
<h3 id="Value-Type의-특징"><a href="#Value-Type의-특징" class="headerlink" title="Value Type의 특징"></a>Value Type의 특징</h3><ul>
<li>변수 할당시 스택 영역에 값 전체가 저장된다.</li>
<li>다른 변수에 할당될 때 값 전체가 복사된다.<ul>
<li>변수들이 서로 분리되므로 한 변수에 대한 변경이 다른 것에 영향을 미치지 않는다.</li>
</ul>
</li>
<li>힙 영역을 사용하지 않는다. 그러므로 참조 카운팅도 필요하지 않다.</li>
</ul>
<h4 id="실험"><a href="#실험" class="headerlink" title="실험"></a>실험</h4><h5 id="구조체에-Value-Type-프로퍼티가-존재할-때의-동작"><a href="#구조체에-Value-Type-프로퍼티가-존재할-때의-동작" class="headerlink" title="구조체에 Value Type 프로퍼티가 존재할 때의 동작"></a>구조체에 Value Type 프로퍼티가 존재할 때의 동작</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ValueValue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> value = <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> bar1 = <span class="type">ValueValue</span>()</span><br><span class="line">  <span class="keyword">var</span> bar2 = bar1</span><br><span class="line">  bar2.value = <span class="number">11</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bar2 : (7FFEEFBFF4B0) : 0B 00 00 00 00 00 00 00</span><br><span class="line">bar1 : (7FFEEFBFF4B8) : 0A 00 00 00 00 00 00 00</span><br></pre></td></tr></table></figure>

<p>지역 변수가 저장된 주소는 스택 영역이다.</p>
<p>구조체가 Int 타입 프로퍼티를 하나 가지므로 8바이트가 할당된다.</p>
<p>값 전체를 복사하여 변수들이 서로 분리되는 모습을 확인할 수 있다.</p>
<h5 id="클래스에-Value-Type-프로퍼티가-존재할-때의-동작"><a href="#클래스에-Value-Type-프로퍼티가-존재할-때의-동작" class="headerlink" title="클래스에 Value Type 프로퍼티가 존재할 때의 동작"></a>클래스에 Value Type 프로퍼티가 존재할 때의 동작</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReferenceValue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> value = <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> bar1 = <span class="type">ReferenceValue</span>()</span><br><span class="line">  <span class="keyword">var</span> bar2 = bar1</span><br><span class="line">  bar2.value = <span class="number">11</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bar2 : (7FFEEFBFF4A0) : 20 FF 0A 03 01 00 00 00</span><br><span class="line">bar1 : (7FFEEFBFF4A8) : 20 FF 0A 03 01 00 00 00</span><br><span class="line"></span><br><span class="line">(1030AFF20) : 80 8F 00 00 01 00 00 00</span><br><span class="line">              02 00 00 00 02 00 00 00</span><br><span class="line">              0B 00 00 00 00 00 00 00</span><br></pre></td></tr></table></figure>

<p>지역 변수가 저장된 주소는 스택 영역이다. 클래스의 인스턴스는 힙에 할당되고, 그 주소가 지역 변수에 저장된다. 해당 인스턴스에 대한 참조 카운트가 1로 설정된다.</p>
<p>64비트 시스템에서 주소는 8바이트이므로 지역 변수를 위해 8바이트가 할당된다.</p>
<p><code>var bar2 = bar1</code>에 의해 클래스의 인스턴스의 참조 카운트가 증가하여 2가 된다.</p>
<p>1030AFF20 주소로 가보면 위와 같은 결과를 확인할 수 있다. </p>
<ul>
<li><p>첫 8바이트의 100008F80 주소는 데이터 영역이다. (TODO: 무엇이 들어있을까?)</p>
</li>
<li><p>다음 8바이트 (TODO: 무엇이 들어있을까?)</p>
</li>
<li><p>마지막 8바이트에 11이 저장되어 있다.</p>
</li>
</ul>
<p>참조가 복사되었으므로 변수들이 분리되지 않은 모습을 확인할 수 있다.</p>
<h3 id="Value-Semantics-‘값’에-의해-구분된다"><a href="#Value-Semantics-‘값’에-의해-구분된다" class="headerlink" title="Value Semantics : ‘값’에 의해 구분된다"></a>Value Semantics : ‘값’에 의해 구분된다</h3><ul>
<li>Identity가 아닌 Equality가 중요하다. 각 변수는 값에 의해 구분되어야 한다. </li>
<li>Swift는 <code>Equatable</code> 프로토콜을 구현하여 Equality를 제공할 수 있다. (동등 연산자 구현)</li>
</ul>
<h3 id="Value-Type과-Thread"><a href="#Value-Type과-Thread" class="headerlink" title="Value Type과 Thread"></a>Value Type과 Thread</h3><ul>
<li>Value Type은 쓰레드 안전하다. 값을 공유하는 것이 아닌, 값을 복사하여 넘기기 때문이다.</li>
<li>쓰레드 간 의도하지 않은 공유로부터 안전한다.</li>
</ul>
<h3 id="복사-시-성능-문제"><a href="#복사-시-성능-문제" class="headerlink" title="복사 시 성능 문제?"></a>복사 시 성능 문제?</h3><ul>
<li>복사는 빠르다.<ul>
<li>Struct, Enum, Tuple의 복사<ul>
<li>정해진 시간(constant time) 안에 작업이 완료된다.</li>
</ul>
</li>
<li>Struct의 내부 데이터가 힙에 존재하는 경우 (String, Array, Set, Dictionary 등)<ul>
<li>정해진 시간 + 참조 복사 시간</li>
<li>Copy-on-Write를 통해 복사로 인한 속도 저하를 보완한다. 이를 통해 Value Semantics를 구현한다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="실험-1"><a href="#실험-1" class="headerlink" title="실험"></a>실험</h4><h5 id="정해진-시간은-무엇을-의미하는-것일까"><a href="#정해진-시간은-무엇을-의미하는-것일까" class="headerlink" title="정해진 시간은 무엇을 의미하는 것일까?"></a>정해진 시간은 무엇을 의미하는 것일까?</h5><p>Struct, Enum, Tuple의 복사에 일어나는 정해진 시간은 현실적으로 실험하기 어렵다.</p>
<p>Array 복사를 통해 정해진 시간을 알아보자.</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">let</span> iterationCounts = [<span class="number">10</span>, <span class="number">100</span>, <span class="number">1000</span>, <span class="number">10000</span>, <span class="number">100000</span>, <span class="number">1000000</span>, <span class="number">10000000</span>, <span class="number">100000000</span>]</span><br><span class="line">  <span class="keyword">for</span> iterationCount <span class="keyword">in</span> iterationCounts &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Iteration Count : \(iterationCount)"</span>)</span><br><span class="line">    <span class="keyword">var</span> array = [<span class="type">Int</span>]()</span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> <span class="number">0</span> ..&lt; iterationCount &#123;</span><br><span class="line">      array.append(number)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> startTime = <span class="type">CFAbsoluteTimeGetCurrent</span>()</span><br><span class="line">    <span class="keyword">let</span> array2 = array</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"배열 복사 : \(CFAbsoluteTimeGetCurrent() - startTime)"</span>)</span><br><span class="line">    startTime = <span class="type">CFAbsoluteTimeGetCurrent</span>()</span><br><span class="line">    <span class="keyword">var</span> array3 = array</span><br><span class="line">    array[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"배열 복사 후 쓰기 : \(CFAbsoluteTimeGetCurrent() - startTime)"</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"------------------------"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Iteration Count : 10</span><br><span class="line">배열 복사 : 1.0728836059570312e-06 (약 0.000001초 (1마이크로초))</span><br><span class="line">배열 복사 후 쓰기 : 2.205371856689453e-05 (약 0.00002초 (20마이크로초))</span><br><span class="line">------------------------</span><br><span class="line">Iteration Count : 100</span><br><span class="line">배열 복사 : 0.0</span><br><span class="line">배열 복사 후 쓰기 : 9.5367431640625e-07 (약 0.0000009초 (0.9마이크로초))</span><br><span class="line">------------------------</span><br><span class="line">Iteration Count : 1000</span><br><span class="line">배열 복사 : 9.5367431640625e-07 (약 0.0000009초 (0.9마이크로초))</span><br><span class="line">배열 복사 후 쓰기 : 2.0265579223632812e-06 (약 0.000002초 (2마이크로초))</span><br><span class="line">------------------------</span><br><span class="line">Iteration Count : 10000</span><br><span class="line">배열 복사 : 2.0265579223632812e-06 (약 0.000002초 (2마이크로초))</span><br><span class="line">배열 복사 후 쓰기 : 3.898143768310547e-05 (약 0.00003초 (30마이크로초))</span><br><span class="line">------------------------</span><br><span class="line">Iteration Count : 100000</span><br><span class="line">배열 복사 : 3.0994415283203125e-06 (약 0.000003초 (3마이크로초))</span><br><span class="line">배열 복사 후 쓰기 : 0.0003249645233154297 (약 0.0003초 (0.3밀리초))</span><br><span class="line">------------------------</span><br><span class="line">Iteration Count : 1000000</span><br><span class="line">배열 복사 : 4.0531158447265625e-06 (약 0.000004초 (4마이크로초))</span><br><span class="line">배열 복사 후 쓰기 : 0.0033320188522338867 (약 0.003초 (3밀리초))</span><br><span class="line">------------------------</span><br><span class="line">Iteration Count : 10000000</span><br><span class="line">배열 복사 : 2.9802322387695312e-06 (약 0.000002초 (2마이크로초))</span><br><span class="line">배열 복사 후 쓰기 : 0.03259694576263428 (약 0.03초 (30밀리초))</span><br><span class="line">------------------------</span><br><span class="line">Iteration Count : 100000000</span><br><span class="line">배열 복사 : 2.0265579223632812e-06 (약 0.000002초 (2마이크로초))</span><br><span class="line">배열 복사 후 쓰기 : 0.34505295753479004 (약 0.3초 (300밀리초))</span><br><span class="line">------------------------</span><br></pre></td></tr></table></figure>

<p>실험 결과 배열의 복사는 마이크로초 단위의 정해진 시간 안에 수행되는 것을 확인할 수 있다.</p>
<p>Copy-on-Write에 의해 복사 후 쓰기가 일어날 때 복사되며, 배열 복사 후 쓰기 시간이 갈수록 증가한다는 것을 확인할 수 있다.</p>
<p>이처럼 복사가 성능에 영향을 미칠 것으로 생각되지만 복사는 정해진 시간 안에 일어나 매우 빠르며, 내부 데이터를 힙에 할당하는 Value Type에 대해서도 Copy-on-Write를 통해 쓰기 시에 실제 복사가 일어나게 하여 성능 저하 요소를 해결한다.</p>
<h5 id="Array의-요소가-힙에-저장된다고"><a href="#Array의-요소가-힙에-저장된다고" class="headerlink" title="Array의 요소가 힙에 저장된다고?"></a>Array의 요소가 힙에 저장된다고?</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">  withUnsafeBytes(of: &amp;array) &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UnsafeRawBufferPointer(start: 0x00007ffeefbff4a8, count: 8)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">array : (7FFEEFBFF4A8) : 00 25 53 00 01 00 00 00</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(100532500) : A0 19 B3 94 FF 7F 00 00</span><br><span class="line">              02 00 00 00 00 00 00 00</span><br><span class="line">              05 00 00 00 00 00 00 00</span><br><span class="line">              0A 00 00 00 00 00 00 00</span><br><span class="line">              01 00 00 00 00 00 00 00</span><br><span class="line">              02 00 00 00 00 00 00 00</span><br><span class="line">              03 00 00 00 00 00 00 00</span><br><span class="line">              04 00 00 00 00 00 00 00</span><br><span class="line">              05 00 00 00 00 00 00 00</span><br></pre></td></tr></table></figure>

<p>Array는 Struct로 구현되었지만 실제로는 주소를 저장하기 위한 8바이트를 할당받고 힙에 배열의 요소를 저장하고 있음을 확인할 수 있다.</p>
<h3 id="Reference-Type을-Immutable하게-만들면-되지-않는가"><a href="#Reference-Type을-Immutable하게-만들면-되지-않는가" class="headerlink" title="Reference Type을 Immutable하게 만들면 되지 않는가?"></a>Reference Type을 Immutable하게 만들면 되지 않는가?</h3><ul>
<li>Reference Type이라도 Immutable하면 쓰레드 간 공유에 문제가 생길 일이 없다. <ul>
<li>불변 == 인스턴스가 만들어지고 나서 수정할 수 없기 때문</li>
</ul>
</li>
<li>Foundation 프레임워크에도 <code>NSArray</code>, <code>NSAttributedString</code>과 같은 불변 객체가 정의되어 있다.</li>
<li>하지만 언제나 Immutable한 것이 좋은 것은 아니며, Mutable한 것이 효율적인 경우가 있다.</li>
</ul>
<h4 id="Immutable한-설계가-어울리지-않는-경우"><a href="#Immutable한-설계가-어울리지-않는-경우" class="headerlink" title="Immutable한 설계가 어울리지 않는 경우"></a>Immutable한 설계가 어울리지 않는 경우</h4><h5 id="Immutable-객체를-갱신하기-위해-매번-새로운-객체를-만들고-할당하는-경우"><a href="#Immutable-객체를-갱신하기-위해-매번-새로운-객체를-만들고-할당하는-경우" class="headerlink" title="Immutable 객체를 갱신하기 위해 매번 새로운 객체를 만들고 할당하는 경우"></a>Immutable 객체를 갱신하기 위해 매번 새로운 객체를 만들고 할당하는 경우</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array = <span class="type">NSArray</span>()</span><br><span class="line"><span class="keyword">for</span> number <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] &#123;</span><br><span class="line">  array = array.adding(number) <span class="keyword">as</span> <span class="type">NSArray</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이러한 경우 아래와 같이 Immutable한 <code>NSArray</code> 대신  <code>NSMutableArray</code>를 사용하여 Mutable 객체에 새로운 객체를 추가하는 방식을 취하는 것이 효율적이다.</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array = <span class="type">NSMutableArray</span>()</span><br><span class="line"><span class="keyword">for</span> number <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] &#123;</span><br><span class="line">  array.add(number)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="API가-이상해지는-경우"><a href="#API가-이상해지는-경우" class="headerlink" title="API가 이상해지는 경우"></a>API가 이상해지는 경우</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Mutable API</span></span><br><span class="line">car.dashboard.speed = <span class="number">100</span></span><br><span class="line"><span class="comment">// Immutable API</span></span><br><span class="line">car.dashboard = <span class="type">Car</span>.<span class="type">Dashboard</span>(speed: <span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<p>Car.Dashboard가 Immutable한 경우 speed 프로퍼티를 바꿔야 할 때마다 새로운 객체를 만들어 할당해 주어야 한다.</p>
<p>사람이 볼 때도 어울리지 않고, 객체를 새로 할당하므로 컴파일러가 최적화하기도 어렵다.</p>
<h3 id="그래도-클래스는-중요하다"><a href="#그래도-클래스는-중요하다" class="headerlink" title="그래도 클래스는 중요하다."></a>그래도 클래스는 중요하다.</h3><ul>
<li>Identity가 Equality보다 중요한 경우</li>
<li>객체 지향 프로그래밍<ul>
<li>상속은 여전히 훌륭한 도구다.</li>
</ul>
</li>
<li>Objective-C 연동<ul>
<li>Cocoa / Cocoa Touch 프레임워크는 클래스로 구성되었다.</li>
</ul>
</li>
<li>Indirect Storage<ul>
<li>특수한 경우 Struct 내부의 간접 저장소 역할을 한다.</li>
</ul>
</li>
</ul>
<h2 id="성능을-위해-고려할-것들"><a href="#성능을-위해-고려할-것들" class="headerlink" title="성능을 위해 고려할 것들"></a>성능을 위해 고려할 것들</h2><blockquote>
<p>성능에 영향을 미치는 것들</p>
<ol>
<li>메모리 할당 : 스택 or 힙</li>
<li>참조 카운팅 발생 여부 : true or false</li>
<li>메소드 디스패치 : 정적 or 동적 (호출할 메소드를 결정하는 것이 컴파일 타임에 일어나는가, 런타임에 일어나는가)</li>
</ol>
</blockquote>
<h3 id="메모리-할당"><a href="#메모리-할당" class="headerlink" title="메모리 할당"></a>메모리 할당</h3><h4 id="힙-할당-문제"><a href="#힙-할당-문제" class="headerlink" title="힙 할당 문제"></a>힙 할당 문제</h4><p>힙에 할당할 때 비어 있는 곳을 찾고 관리하기 위한 오버헤드가 존재한다. 단편화 현상을 피할 수 없다.</p>
<p>위의 과정이 쓰레드 안전해야 하기 때문에 lock 등의 동기화 기법을 사용하며, 이것이 큰 성능 저하 요소가 된다.</p>
<p>반면 스택 할당은 단순히 스택 포인터 값만 바꿔주면 된다.</p>
<ul>
<li>스택 포인터 : 레지스터에 기록되어 있으며, 스택에 데이터가 채워진 위치를 가리킨다.</li>
</ul>
<h4 id="힙-할당-줄이기"><a href="#힙-할당-줄이기" class="headerlink" title="힙 할당 줄이기"></a>힙 할당 줄이기</h4><p>예를 들어 String을 키 값으로 사용하는 캐시 객체가 있을 때, 키 값을 코드에서 만들 때마다 해당 값이 힙에 할당되게 된다.</p>
<p>이러한 행위가 빈번하게 일어난다면 성능에 영향을 미칠 수 있을 것이다.</p>
<p>이 경우 키를 Value Type으로 바꾸어 힙 할당을 줄여볼 수 있다.</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 이전</span></span><br><span class="line"><span class="keyword">let</span> key = <span class="string">"\(color)\(theme)\(selected)"</span></span><br><span class="line"><span class="comment">// 이후</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span> </span>&#123; &#125;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Theme</span> </span>&#123; &#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Attribute</span>: <span class="title">Hashable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> color: <span class="type">Color</span></span><br><span class="line">  <span class="keyword">var</span> theme: <span class="type">Theme</span></span><br><span class="line">  <span class="keyword">var</span> selected: <span class="type">Bool</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> key = <span class="type">Attribute</span>(color: color, theme: theme, selected: selected)</span><br></pre></td></tr></table></figure>

<p>키 값은 완전하게 Value Type으로 대체되어 힙에 할당될 일이 없게 된다.</p>
<h3 id="참조-카운팅-발생-여부"><a href="#참조-카운팅-발생-여부" class="headerlink" title="참조 카운팅 발생 여부"></a>참조 카운팅 발생 여부</h3><h4 id="참조-카운팅의-문제"><a href="#참조-카운팅의-문제" class="headerlink" title="참조 카운팅의 문제"></a>참조 카운팅의 문제</h4><p>참조 카운팅은 알게 모르게 정말 많이 발생한다. 참조 타입의 변수를 복사할 때마다 발생하기 때문이다.</p>
<p>또한 참조 카운팅도 쓰레드 안전하게 발생해야 한다는 문제가 있다. 카운트를 Atomic하게 증감시켜야 한다.</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(<span class="number">_</span> a: A)</span></span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">let</span> a0 = <span class="type">A</span>()</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">var</span> a1: <span class="type">A?</span> = a0</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line">foo(a0)</span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line">a1 = <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<ol>
<li>A 클래스의 인스턴스를 힙에 할당하고 그 주소를 <code>a0</code> 변수가 가지고 있게 한다. 해당 인스턴스의 참조 카운트는 1이 된다.<ul>
<li><code>new</code> -&gt; 1</li>
</ul>
</li>
<li><code>c1</code> 변수가 <code>c0</code>가 가리키는 인스턴스를 가리키게 한다. 해당 인스턴스의 참조 카운트는 2가 된다.<ul>
<li><code>retain</code> -&gt; 2</li>
</ul>
</li>
<li><code>c0</code>의 참조를 함수에 넘긴다.<ol>
<li>함수의 매개 변수 <code>a</code>가 인스턴스를 참조하므로 함수가 시작될 때 해당 인스턴스의 참조 카운트는 3이 된다.<ul>
<li><code>retain</code> -&gt; 3</li>
</ul>
</li>
<li>함수를 빠져 나갈 때 해당 인스턴스의 참조 카운트는 2가 된다.<ul>
<li><code>release</code> -&gt; 2</li>
</ul>
</li>
</ol>
</li>
<li><code>c1</code>의 참조를 nil로 바꾼다. <code>c1</code>에 대해 release가 발생하여 해당 인스턴스의 참조 카운트는 1이 된다.<ul>
<li><code>release</code> -&gt; 1</li>
</ul>
</li>
</ol>
<p>ARC에서 retain과 release 같은 것은 컴파일러가 작성한다.</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span> ..&lt; <span class="number">1000000</span> &#123;</span><br><span class="line">  foo(c0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위의 코드처럼 참조 타입이 인자로 넘어가는 함수가 여러 번 호출된다면 retain과 release가 매우 빈번하게 발생할 수 있다. 이는 성능 저하 요소가 된다.</p>
<h4 id="실험-2"><a href="#실험-2" class="headerlink" title="실험"></a>실험</h4><h5 id="참조-카운팅-직접-확인"><a href="#참조-카운팅-직접-확인" class="headerlink" title="참조 카운팅 직접 확인"></a>참조 카운팅 직접 확인</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">deinit</span> &#123; <span class="built_in">print</span>(<span class="string">"deinit"</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(<span class="number">_</span> a: A?)</span></span> &#123; <span class="built_in">print</span>(<span class="type">CFGetRetainCount</span>(a)) &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a0: <span class="type">A?</span> = <span class="type">A</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="type">CFGetRetainCount</span>(a0))</span><br><span class="line"><span class="keyword">var</span> a1: <span class="type">A?</span> = a0</span><br><span class="line"><span class="built_in">print</span>(<span class="type">CFGetRetainCount</span>(a0))</span><br><span class="line">foo(a0)</span><br><span class="line"><span class="built_in">print</span>(<span class="type">CFGetRetainCount</span>(a0))</span><br><span class="line">a1 = <span class="literal">nil</span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">CFGetRetainCount</span>(a0))</span><br><span class="line">a0 = <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">deinit</span><br></pre></td></tr></table></figure>

<p>위의 설명과 동일하다.</p>
<p>참조 카운트가 2부터 시작하는 것은 신경쓰지 말자…</p>
<h3 id="메소드-디스패치"><a href="#메소드-디스패치" class="headerlink" title="메소드 디스패치"></a>메소드 디스패치</h3><h4 id="정적-메소드-디스패치"><a href="#정적-메소드-디스패치" class="headerlink" title="정적 메소드 디스패치"></a>정적 메소드 디스패치</h4><p>컴파일 시점에 메소드의 실제 위치를 알 수 있다면 런타임에서 찾는 과정 없이 바로 해당 코드가 위치한 주소로 점프할 수 있다.</p>
<p>이 경우 컴파일러가 코드를 최적화할 수 있는 가능성이 생기며, 메소드 인라이닝도 가능해진다.</p>
<h5 id="메소드-인라이닝"><a href="#메소드-인라이닝" class="headerlink" title="메소드 인라이닝"></a>메소드 인라이닝</h5><p>컴파일 타임에 효과적이라고 판단될 때 메소드 호출 부분에 메소드 내용을 붙여 넣는다.</p>
<p>함수 호출 스택에 대한 오버헤드를 줄여 CPU i-cache(명령어 캐시)나 레지스터를 효율적으로 사용할 가능성이 있다.</p>
<p>메소드 인라이닝이 가능해지면 추가적인 최적화가 가능하다.</p>
<p>최근 메소드의 크기가 점점 더 작아지고 있으므로 더더욱 최적화의 기회가 많아진다.</p>
<p>루프 안에서 메소드가 호출되는 경우 큰 효과를 얻을 수 있다.</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x: <span class="type">CGFloat</span></span><br><span class="line">  <span class="keyword">var</span> y: <span class="type">CGFloat</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">draw</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(x, y)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">drawPoint</span><span class="params">(<span class="number">_</span> point: Point)</span></span> &#123;</span><br><span class="line">  point.draw()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> point = <span class="type">Point</span>(x: <span class="number">0</span>, y: <span class="number">0</span>)</span><br><span class="line">drawPoint(point)</span><br></pre></td></tr></table></figure>

<ol>
<li><code>drawPoint(point)</code> 메소드의 위치는 컴파일 타임에 결정 가능하므로 <code>point.draw()</code>로 대체할 수 있다.</li>
<li><code>point.draw()</code> 메소드의 위치는 컴파일 타임에 결정 가능하므로 <code>print(point.x, point.y)</code>로 대체할 수 있다.</li>
</ol>
<p>결국 <code>drawPoint(point)</code>는 <code>print(point.x, point.y)</code>로 대체된다.</p>
<p>두 번의 호출이 줄었다. 코드가 붙어 추가적인 최적화의 기회가 생긴다.</p>
<h4 id="동적-메소드-디스패치"><a href="#동적-메소드-디스패치" class="headerlink" title="동적 메소드 디스패치"></a>동적 메소드 디스패치</h4><p>다형성의 개념을 사용한 경우 정적 메소드 디스패치를 할 수 없다.</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Drawable</span> </span>&#123; <span class="function"><span class="keyword">func</span> <span class="title">draw</span><span class="params">()</span></span> &#123; &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>: <span class="title">Drawable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x: <span class="type">CGFloat</span></span><br><span class="line">  <span class="keyword">var</span> y: <span class="type">CGFloat</span></span><br><span class="line">  <span class="comment">// init</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">draw</span><span class="params">()</span></span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span>: <span class="title">Drawable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x1: <span class="type">CGFloat</span></span><br><span class="line">  <span class="keyword">var</span> y1: <span class="type">CGFloat</span></span><br><span class="line">  <span class="keyword">var</span> x2: <span class="type">CGFloat</span></span><br><span class="line">  <span class="keyword">var</span> y2: <span class="type">CGFloat</span></span><br><span class="line">  <span class="comment">// init</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">draw</span><span class="params">()</span></span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">draw</span><span class="params">(<span class="number">_</span> drawable: Drawable)</span></span> &#123;</span><br><span class="line">  drawable.draw()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>draw()</code> 함수는 다형성 기법을 사용하여 <code>Drawable</code> 타입의 객체를 인자로 요구한다.</p>
<p><code>drawable.draw()</code>가 <code>Point.draw</code>일지, <code>Line.draw</code>일지, <code>Drawable.draw</code>일지 컴파일 타임에서 알 수 없다.</p>
<p>런타임에서,</p>
<ol>
<li>클래스의 실제 타입을 찾아내고</li>
<li>해당 클래스 타입에 속한 V-Table을 찾고</li>
<li>실제 메소드(<code>draw</code>)의 코드 주소를 찾아내어 호출한다.</li>
</ol>
<p>이것이 동적 메소드 디스패치다.</p>
<h4 id="동적-메소드-디스패치의-문제"><a href="#동적-메소드-디스패치의-문제" class="headerlink" title="동적 메소드 디스패치의 문제"></a>동적 메소드 디스패치의 문제</h4><p>쓰레드 안전 문제도 없다.</p>
<p>하지만 실제 타입을 런타임에 찾아 메소드 코드의 주소를 찾으므로, 컴파일러가 코드를 최적화할 수 없게 된다.</p>
<h4 id="Objective-C의-메소드-디스패치"><a href="#Objective-C의-메소드-디스패치" class="headerlink" title="Objective-C의 메소드 디스패치"></a>Objective-C의 메소드 디스패치</h4><p>Objective-C의 메소드 디스패치는 메세지 전달 방식으로 일어난다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 1</span><br><span class="line">[object foo:parameter];</span><br><span class="line">&#x2F;&#x2F; 2</span><br><span class="line">objc_msgSend(object, @selector(foo:), parameter);</span><br></pre></td></tr></table></figure>

<p>Objective-C에서 1과 같이 작성된 코드는 2와 같이 Objective-C 런타임 함수를 사용하는 코드로 변환되어, 동적으로 메소드를 Lookup하여 호출한다.</p>
<p>이는 강력하고 유연한 특징을 가지고 있으나 메소드 인라이닝 같은 것을 할 수 없어 성능 저하 요소가 된다.</p>
<p>특히 루프 안에서 메소드가 빈번하게 호출되는 경우 더욱 그렇다.</p>
<h4 id="정적-디스패치로-강제하기"><a href="#정적-디스패치로-강제하기" class="headerlink" title="정적 디스패치로 강제하기"></a>정적 디스패치로 강제하기</h4><ul>
<li>final, private을 쓰는 습관을 들이기<ul>
<li>해당 메소드와 프로퍼티 등은 상속되지 않는다는 것이 보장되어 정적으로 처리되고, 컴파일 타임에 해당 주소를 알 수 있다.</li>
<li>가능한 한 접근 수준을 최소화하기</li>
</ul>
</li>
<li>dynamic 사용하지 않기</li>
<li>Objective-C 연동 최소화<ul>
<li>Objective-C와 연동하는 경우 Objective-C 런타임을 통하게 되어 컴파일 타임 최적화가 힘들다.</li>
</ul>
</li>
<li>WMO(whole module optimization) 활성화<ul>
<li>WMO : 빌드 시에 모든 파일을 한번에 분석하여 정적 디스패치로 변환 가능한지 판단하여 최적화</li>
</ul>
</li>
</ul>
<h4 id="실험-3"><a href="#실험-3" class="headerlink" title="실험"></a>실험</h4><h5 id="final-class-vs-class"><a href="#final-class-vs-class" class="headerlink" title="final class vs. class"></a>final class vs. class</h5><h6 id="final-class"><a href="#final-class" class="headerlink" title="final class"></a>final class</h6><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> foo = <span class="number">3</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">bar</span><span class="params">()</span></span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sil_vtable SomeClass &#123;</span><br><span class="line">  #SomeClass.init!allocator.1: (SomeClass.Type) -&gt; () -&gt; SomeClass : @$s4main9SomeClassCACycfC	&#x2F;&#x2F; SomeClass.__allocating_init()</span><br><span class="line">  #SomeClass.deinit!deallocator.1: @$s4main9SomeClassCfD	&#x2F;&#x2F; SomeClass.__deallocating_deinit</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="class"><a href="#class" class="headerlink" title="class"></a>class</h6><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> foo = <span class="number">3</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">bar</span><span class="params">()</span></span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedSomeClass</span>: <span class="title">SomeClass</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sil_vtable SomeClass &#123;</span><br><span class="line">  #SomeClass.foo!getter.1: (SomeClass) -&gt; () -&gt; Int : @$s4main9SomeClassC3fooSivg	&#x2F;&#x2F; SomeClass.foo.getter</span><br><span class="line">  #SomeClass.foo!setter.1: (SomeClass) -&gt; (Int) -&gt; () : @$s4main9SomeClassC3fooSivs	&#x2F;&#x2F; SomeClass.foo.setter</span><br><span class="line">  #SomeClass.foo!modify.1: (SomeClass) -&gt; () -&gt; () : @$s4main9SomeClassC3fooSivM&#x2F;&#x2F; SomeClass.foo.modify</span><br><span class="line">  #SomeClass.bar!1: (SomeClass) -&gt; () -&gt; () : @$s4main9SomeClassC3baryyF	&#x2F;&#x2F; SomeClass.bar()</span><br><span class="line">  #SomeClass.init!allocator.1: (SomeClass.Type) -&gt; () -&gt; SomeClass : @$s4main9SomeClassCACycfC	&#x2F;&#x2F; SomeClass.__allocating_init()</span><br><span class="line">  #SomeClass.deinit!deallocator.1: @$s4main9SomeClassCfD	&#x2F;&#x2F; SomeClass.__deallocating_deinit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sil_vtable DerivedSomeClass &#123;</span><br><span class="line">  #SomeClass.foo!getter.1: (SomeClass) -&gt; () -&gt; Int : @$s4main9SomeClassC3fooSivg [inherited]	&#x2F;&#x2F; SomeClass.foo.getter</span><br><span class="line">  #SomeClass.foo!setter.1: (SomeClass) -&gt; (Int) -&gt; () : @$s4main9SomeClassC3fooSivs [inherited]	&#x2F;&#x2F; SomeClass.foo.setter</span><br><span class="line">  #SomeClass.foo!modify.1: (SomeClass) -&gt; () -&gt; () : @$s4main9SomeClassC3fooSivM [inherited]	&#x2F;&#x2F; SomeClass.foo.modify</span><br><span class="line">  #SomeClass.bar!1: (SomeClass) -&gt; () -&gt; () : @$s4main9SomeClassC3baryyF [inherited]	&#x2F;&#x2F; SomeClass.bar()</span><br><span class="line">  #SomeClass.init!allocator.1: (SomeClass.Type) -&gt; () -&gt; SomeClass : @$s4main16DerivedSomeClassCACycfC [override]	&#x2F;&#x2F; DerivedSomeClass.__allocating_init()</span><br><span class="line">  #DerivedSomeClass.deinit!deallocator.1: @$s4main16DerivedSomeClassCfD	&#x2F;&#x2F; DerivedSomeClass.__deallocating_deinit</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>실제 V-Table을 살펴봤을 때, final class의 메소드는 V-Table에 위치하지 않는 반면 class의 메소드는 V-Table에 위치하는 것을 확인할 수 있다.</p>
<p>var로 선언된 저장 프로퍼티의 경우 프로퍼티에 대한 getter, setter, modify 메소드가 내부적으로 생성되며, 이 또한 final class의 경우 V-Table에 위치하지 않는 것을 확인할 수 있다.</p>
<h5 id="final-method-vs-normal-method"><a href="#final-method-vs-normal-method" class="headerlink" title="final method vs. normal method"></a>final method vs. normal method</h5><h6 id="final-method"><a href="#final-method" class="headerlink" title="final method"></a>final method</h6><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sil_vtable SomeClass &#123;</span><br><span class="line">  #SomeClass.init!allocator.1: (SomeClass.Type) -&gt; () -&gt; SomeClass : @$s4main9SomeClassCACycfC	&#x2F;&#x2F; SomeClass.__allocating_init()</span><br><span class="line">  #SomeClass.deinit!deallocator.1: @$s4main9SomeClassCfD	&#x2F;&#x2F; SomeClass.__deallocating_deinit</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="normal-method"><a href="#normal-method" class="headerlink" title="normal method"></a>normal method</h6><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sil_vtable SomeClass &#123;</span><br><span class="line">  #SomeClass.foo!1: (SomeClass) -&gt; () -&gt; () : @$s4main9SomeClassC3fooyyF	&#x2F;&#x2F; SomeClass.foo()</span><br><span class="line">  #SomeClass.init!allocator.1: (SomeClass.Type) -&gt; () -&gt; SomeClass : @$s4main9SomeClassCACycfC	&#x2F;&#x2F; SomeClass.__allocating_init()</span><br><span class="line">  #SomeClass.deinit!deallocator.1: @$s4main9SomeClassCfD	&#x2F;&#x2F; SomeClass.__deallocating_deinit</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>final 선언이 붙은 메소드는 상속되지 않는 것을 보장하며, V-Table에 위치하지 않는 것을 확인할 수 있다.</p>
<h3 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h3><p>메모리 할당은 힙이 아닌 스택에 일어나게 하는 것이 좋다. 힙의 비어 있는 공간을 찾고 할당하는 것은 쓰레드 안전하게 일어나야 하며, 이 과정에서 발생하는 동기화 작업이 성능 저하를 불러 일으킨다.</p>
<p>참조 카운팅은 일어나지 않게 하는 것이 좋다. 참조 카운팅은 쓰레드 안전하게, Atomic하게 일어나야 하며, 이 과정에서 발생하는 동기화 작업이 성능 저하를 불러 일으킨다.</p>
<p>메소드 디스패치는 동적이 아닌 정적으로 일어나게 하는 것이 좋다. 정적 메소드 디스패치는 메소드 인라이닝 등 컴파일 타임에서 코드를 최적화하는 기회를 많이 주지만, 동적 메소드 디스패치는 그렇지 않다.</p>
<h2 id="스위프트의-추상화-기법들의-성능"><a href="#스위프트의-추상화-기법들의-성능" class="headerlink" title="스위프트의 추상화 기법들의 성능"></a>스위프트의 추상화 기법들의 성능</h2><blockquote>
<p>Class / Struct / Protocol Type / Generic Type</p>
</blockquote>
<h3 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h3><h4 id="Class-1"><a href="#Class-1" class="headerlink" title="Class"></a>Class</h4><table>
<thead>
<tr>
<th>구분</th>
<th>내용</th>
</tr>
</thead>
<tbody><tr>
<td>메모리 할당</td>
<td>힙</td>
</tr>
<tr>
<td>참조 카운팅 발생 여부</td>
<td>true</td>
</tr>
<tr>
<td>메소드 디스패치</td>
<td>동적 (V-Table 사용)</td>
</tr>
</tbody></table>
<ul>
<li>성능에 관계 없이 Reference Semantics가 필요하다면 사용해야 한다. (Identity 등)</li>
<li>참조의 의도치 않은 공유로 인한 문제를 신경써야 한다.</li>
</ul>
<h4 id="Final-Class"><a href="#Final-Class" class="headerlink" title="Final Class"></a>Final Class</h4><table>
<thead>
<tr>
<th>구분</th>
<th>내용</th>
</tr>
</thead>
<tbody><tr>
<td>메모리 할당</td>
<td>힙</td>
</tr>
<tr>
<td>참조 카운팅 발생 여부</td>
<td>true</td>
</tr>
<tr>
<td>메소드 디스패치</td>
<td>정적</td>
</tr>
</tbody></table>
<ul>
<li>final class는 상속될 수 없으므로 정적 메소드 디스패치가 일어난다.</li>
<li>그러므로 해당 부분에서 일반 클래스보다 성능 상 이점을 취할 수 있다.</li>
</ul>
<h3 id="Struct"><a href="#Struct" class="headerlink" title="Struct"></a>Struct</h3><h4 id="참조-타입을-갖지-않는-Struct"><a href="#참조-타입을-갖지-않는-Struct" class="headerlink" title="참조 타입을 갖지 않는 Struct"></a>참조 타입을 갖지 않는 Struct</h4><table>
<thead>
<tr>
<th>구분</th>
<th>내용</th>
</tr>
</thead>
<tbody><tr>
<td>메모리 할당</td>
<td>스택</td>
</tr>
<tr>
<td>참조 카운팅 발생 여부</td>
<td>false</td>
</tr>
<tr>
<td>메소드 디스패치</td>
<td>정적</td>
</tr>
</tbody></table>
<ul>
<li>구조체는 상속을 지원하지 않으므로 정적 메소드 디스패치가 일어난다.</li>
</ul>
<h4 id="참조-타입을-갖는-Struct"><a href="#참조-타입을-갖는-Struct" class="headerlink" title="참조 타입을 갖는 Struct"></a>참조 타입을 갖는 Struct</h4><table>
<thead>
<tr>
<th>구분</th>
<th>내용</th>
</tr>
</thead>
<tbody><tr>
<td>메모리 할당</td>
<td>스택</td>
</tr>
<tr>
<td>참조 카운팅 발생 여부</td>
<td>true (참조 타입 프로퍼티의 개수만큼 발생)</td>
</tr>
<tr>
<td>메소드 디스패치</td>
<td>정적</td>
</tr>
</tbody></table>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Label</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> text: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> font: <span class="type">UIFont</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">let</span> font = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">15</span>)</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">let</span> label = <span class="type">Label</span>(text: <span class="string">"msg"</span>, font: font)</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="keyword">let</span> label2 = label</span><br></pre></td></tr></table></figure>

<p>UIFont는 클래스. String은 Struct로 구현되었으나 내부 데이터가 힙에 할당되므로 내부 데이터에 대한 참조 카운팅 발생.</p>
<ol>
<li>1이 실행될 때 UIFont 클래스의 인스턴스가 힙에 할당되며 <code>font</code> 변수가 해당 인스턴스의 참조를 기억한다. 해당 인스턴스의 참조 카운트는 1이다.</li>
<li>2가 실행될 때 Label 구조체의 인스턴스가 스택에 할당되며 <code>label</code> 변수가 해당 인스턴스를 나타낸다. <ul>
<li><code>text</code> 프로퍼티는 String 타입이므로 내부 데이터는 힙에 인스턴스를 할당하며 1의 참조 카운트를 갖는다.</li>
<li><code>font</code> 프로퍼티는 <code>font</code> 변수가 참조하는 인스턴스를 참조하므로 해당 인스턴스는 2의 참조 카운트를 갖는다.</li>
</ul>
</li>
<li>3이 실행될 때 <code>label</code> 구조체를 복사하여  <code>label2</code> 변수에 할당하고 스택에 쌓인다.<ul>
<li>하지만 각 프로퍼티가 참조하는 힙에 위치한 인스턴스에 대한 참조 카운트가 증가한다.<ul>
<li><code>text</code> 프로퍼티의 내부 데이터가 참조하는 인스턴스는 2의 참조 카운트를 갖는다.</li>
<li><code>font</code> 프로퍼티가 참조하는 인스턴스는 3의 참조 카운트를 갖는다.</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>이처럼 한 번의 복사가 일어날 때마다 참조 타입 프로퍼티의 개수만큼 참조 카운팅이 발생한다.</p>
<h4 id="참조-타입을-갖는-Struct가-참조-타입을-적게-갖도록-리팩토링하기"><a href="#참조-타입을-갖는-Struct가-참조-타입을-적게-갖도록-리팩토링하기" class="headerlink" title="참조 타입을 갖는 Struct가 참조 타입을 적게 갖도록 리팩토링하기"></a>참조 타입을 갖는 Struct가 참조 타입을 적게 갖도록 리팩토링하기</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HTTPRequest</span> </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> `<span class="class"><span class="keyword">protocol</span>`: <span class="title">String</span></span></span><br><span class="line"><span class="class">	<span class="title">var</span> <span class="title">domain</span>: <span class="title">String</span></span></span><br><span class="line"><span class="class">  <span class="title">var</span> <span class="title">path</span>: <span class="title">String</span></span></span><br><span class="line"><span class="class">	<span class="title">var</span> <span class="title">filename</span>: <span class="title">String</span></span></span><br><span class="line"><span class="class">  <span class="title">var</span> `<span class="title">extension</span>`: <span class="title">String</span></span></span><br><span class="line"><span class="class">  <span class="title">var</span> <span class="title">query</span>: [<span class="title">String</span>: <span class="title">String</span>]</span></span><br><span class="line"><span class="class">  <span class="title">var</span> <span class="title">httpMethod</span>: <span class="title">String</span></span></span><br><span class="line"><span class="class">  <span class="title">var</span> <span class="title">httpVersion</span>: <span class="title">String</span></span></span><br><span class="line"><span class="class">  <span class="title">var</span> <span class="title">httpHost</span>: <span class="title">String</span></span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure>

<p>위의 코드는 9개의 참조 타입을 갖는다. 복사할 때마다 아홉 번의 참조 카운팅이 발생한다.</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">HTTPMethod</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="keyword">get</span></span><br><span class="line">  <span class="keyword">case</span> post</span><br><span class="line">  <span class="keyword">case</span> put</span><br><span class="line">  <span class="keyword">case</span> delete</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">HTTPVersion</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> v1</span><br><span class="line">  <span class="keyword">case</span> v2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HTTPRequest</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> urlString: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> httpMethod: <span class="type">HTTPMethod</span></span><br><span class="line">  <span class="keyword">var</span> httpVersion: <span class="type">HTTPVersion</span></span><br><span class="line">  <span class="keyword">var</span> httpHost: <span class="type">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>protocol, domain, path, filename, extension, query는 하나의 프로퍼티(urlString)가 모두 갖도록 바꿨다.</p>
<p><code>httpMethod</code> / <code>httpVersion</code>의 값은 제한 가능하므로 String 대신 관련 열거형의 인스턴스를 갖도록 한다.</p>
<p>HTTPMethod 열거형을 정의하여  httpMethod 프로퍼티가 해당 타입의 값을 갖도록 한다.</p>
<p>HTTPVersion 열거형을 정의하여  httpVersion 프로퍼티가 해당 타입의 값을 갖도록 한다.</p>
<p>결과적으로 두 개의 참조 타입과 두 개의 값 타입을 갖게 된다. 복사할 때마다 두 번의 참조 카운팅이 발생한다.</p>
<p>값의 제한이 가능하다면 Enum과 같은 Value Type으로 변경할 수 있고, 여러 개의 클래스를 하나의 클래스로 몰아 넣을 수 있다.</p>
<h3 id="Protocol-Type"><a href="#Protocol-Type" class="headerlink" title="Protocol Type"></a>Protocol Type</h3><h4 id="Protocol"><a href="#Protocol" class="headerlink" title="Protocol"></a>Protocol</h4><ul>
<li>구현 없이 선언만 정의한다.</li>
<li>상속 없는 다형성 구현이 가능하다.</li>
<li>Value Type인 Struct나 Enum에 적용 가능하다.<ul>
<li>Value Semantics에서의 다형성 구현</li>
</ul>
</li>
</ul>
<h4 id="Protocol을-이용한-Value-Type-다형성"><a href="#Protocol을-이용한-Value-Type-다형성" class="headerlink" title="Protocol을 이용한 Value Type 다형성"></a>Protocol을 이용한 Value Type 다형성</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Drawable</span> </span>&#123; <span class="function"><span class="keyword">func</span> <span class="title">draw</span><span class="params">()</span></span> &#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span>: <span class="title">Drawable</span> </span>&#123; <span class="function"><span class="keyword">func</span> <span class="title">draw</span><span class="params">()</span></span> &#123; ... &#125; &#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span>: <span class="title">Drawable</span> </span>&#123; <span class="function"><span class="keyword">func</span> <span class="title">draw</span><span class="params">()</span></span> &#123; ... &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> drawables: [<span class="type">Drawable</span>] = [<span class="type">Point</span>(), <span class="type">Line</span>()]</span><br><span class="line"><span class="keyword">for</span> drawable <span class="keyword">in</span> drawables &#123;</span><br><span class="line">  drawable.draw()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>반복문 안에서 <code>draw()</code> 메소드를 호출하는 타입은 Protocol인 <code>Drawable</code> 타입이다.</p>
<p>이렇게 Value Type에서도 Protocol을 사용하여 다형성을 구현할 수 있다.</p>
<h4 id="프로토콜-타입을-사용할-때의-의문"><a href="#프로토콜-타입을-사용할-때의-의문" class="headerlink" title="프로토콜 타입을 사용할 때의 의문"></a>프로토콜 타입을 사용할 때의 의문</h4><ul>
<li><p>변수 할당에 대한 의문</p>
<ul>
<li><p>클래스는 힙에 인스턴스를 생성하고 이를 참조하는 변수는 인스턴스의 주소값을 가지므로, 64비트 시스템에서 변수는 모두 8바이트의 크기를 할당받는다.</p>
</li>
<li><p>구조체는 스택에 서로 다른 크기의 구조체의 인스턴스를 쌓아야 하는데, 프로토콜 타입인 경우에 어떻게 타입의 크기를 알고 값을 스택에 쌓을 수 있을까?</p>
</li>
<li><pre><code class="swift"><span class="keyword">let</span> drawables: [<span class="type">Drawable</span>] = [<span class="type">Point</span>(), <span class="type">Line</span>()]

&lt;!--￼<span class="number">33</span>--&gt;</code></pre>
</li>
</ul>
</li>
<li><p>이렇게 되면 각각의 Existential Container가 별도의 힙 공간을 가리키는 포인터를 갖게 하도록 할 수 있다. </p>
<ul>
<li>여전히 참조 카운팅을 하지만, 참조 카운트는 서로 1씩 갖게 된다.</li>
<li>또한 Value Semantics를 구현하여 값을 분리할 수 있게 된다.</li>
</ul>
</li>
<li><p>이처럼 쓰기 전까지는 참조를 복사하고(얕은 복사), 쓰기가 발생할 때 값을 복사(깊은 복사)하여 성능 상 이점을 취한다.</p>
</li>
<li><p>String, Array, Dictionary 등도 이러한 개념으로 Value Semantics를 구현하였다.</p>
</li>
</ul>
<h4 id="Existential-Container-정리"><a href="#Existential-Container-정리" class="headerlink" title="Existential Container 정리"></a>Existential Container 정리</h4><ul>
<li>Protocol Type일 때 사용된다.</li>
<li>프로토콜을 사용한 다형성을 구현하기 위해 사용된다.</li>
<li>내부 동작이 복잡하긴 하나 성능은 클래스를 사용하는 것과 비슷하다.<ul>
<li>둘 모두 초기화할 때 힙에 공간을 할당한다.</li>
<li>둘 모두 동적 메소드 디스패치를 한다.<ul>
<li>클래스는 V-Table을 사용한다.</li>
<li>프로토콜은 PWT를 사용한다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="작은-사이즈-3워드-이하-의-Protocol-Type"><a href="#작은-사이즈-3워드-이하-의-Protocol-Type" class="headerlink" title="작은 사이즈(3워드 이하)의 Protocol Type"></a>작은 사이즈(3워드 이하)의 Protocol Type</h4><table>
<thead>
<tr>
<th>구분</th>
<th>내용</th>
</tr>
</thead>
<tbody><tr>
<td>메모리 할당</td>
<td>스택 (Existential Container)</td>
</tr>
<tr>
<td>참조 카운팅 발생 여부</td>
<td>false</td>
</tr>
<tr>
<td>메소드 디스패치</td>
<td>동적 (PWT)</td>
</tr>
</tbody></table>
<h4 id="큰-사이즈-3워드-초과-의-Protocol-Type"><a href="#큰-사이즈-3워드-초과-의-Protocol-Type" class="headerlink" title="큰 사이즈(3워드 초과)의 Protocol Type"></a>큰 사이즈(3워드 초과)의 Protocol Type</h4><table>
<thead>
<tr>
<th>구분</th>
<th>내용</th>
</tr>
</thead>
<tbody><tr>
<td>메모리 할당</td>
<td>스택 (Existential Container, 실제 데이터는 힙)</td>
</tr>
<tr>
<td>참조 카운팅 발생 여부</td>
<td>false</td>
</tr>
<tr>
<td>메소드 디스패치</td>
<td>동적 (PWT)</td>
</tr>
</tbody></table>
<p>복사가 발생할 때 값 저장을 위한 새로운 힙 공간을 할당한다.</p>
<h4 id="Indirect-Storage-사용하여-개선한-큰-사이즈-Protocol-Type"><a href="#Indirect-Storage-사용하여-개선한-큰-사이즈-Protocol-Type" class="headerlink" title="Indirect Storage 사용하여 개선한 큰 사이즈 Protocol Type"></a>Indirect Storage 사용하여 개선한 큰 사이즈 Protocol Type</h4><table>
<thead>
<tr>
<th>구분</th>
<th>내용</th>
</tr>
</thead>
<tbody><tr>
<td>메모리 할당</td>
<td>스택 (Existential Container, 실제 데이터는 힙)</td>
</tr>
<tr>
<td>참조 카운팅 발생 여부</td>
<td>true (Indirect Storage가 참조 타입)</td>
</tr>
<tr>
<td>메소드 디스패치</td>
<td>동적 (PWT)</td>
</tr>
</tbody></table>
<p>복사가 발생할 때 새로운 Existential Container를 생성하고 Indirect Storage의 참조를 저장한다.</p>
<p>클래스 수준의 성능을 보여준다.</p>
<h4 id="실험-4"><a href="#실험-4" class="headerlink" title="실험"></a>실험</h4><h5 id="프로토콜-타입일-때와-해당-타입일-경우의-차이는"><a href="#프로토콜-타입일-때와-해당-타입일-경우의-차이는" class="headerlink" title="프로토콜 타입일 때와 해당 타입일 경우의 차이는?"></a>프로토콜 타입일 때와 해당 타입일 경우의 차이는?</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SomeProtocol</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">  <span class="keyword">var</span> b: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SomeStruct</span>: <span class="title">SomeProtocol</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a: <span class="type">Int</span> = <span class="number">10</span></span><br><span class="line">  <span class="keyword">var</span> b: <span class="type">Int</span> = <span class="number">11</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> someStruct1 = <span class="type">SomeStruct</span>()</span><br><span class="line">  <span class="keyword">var</span> someStruct2: <span class="type">SomeProtocol</span> = <span class="type">SomeStruct</span>()</span><br><span class="line">  withUnsafeBytes(of: &amp;someStruct1) &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;</span><br><span class="line">  withUnsafeBytes(of: &amp;someStruct2) &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UnsafeRawBufferPointer(start: 0x00007ffeefbff4a0, count: 16)</span><br><span class="line">UnsafeRawBufferPointer(start: 0x00007ffeefbff478, count: 40)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">someStruct2 : (7FFEEFBFF478) : 0A 00 00 00 00 00 00 00</span><br><span class="line">                               0B 00 00 00 00 00 00 00</span><br><span class="line">                               00 00 00 00 00 00 00 00</span><br><span class="line">                               B8 84 00 00 01 00 00 00</span><br><span class="line">                               38 84 00 00 01 00 00 00</span><br><span class="line">															 </span><br><span class="line">someStruct1 : (7FFEEFBFF4A0) : 0A 00 00 00 00 00 00 00</span><br><span class="line">                               0B 00 00 00 00 00 00 00</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sil_witness_table hidden SomeStruct: SomeProtocol module main &#123;</span><br><span class="line">  method #SomeProtocol.a!getter.1: &lt;Self where Self : SomeProtocol&gt; (Self) -&gt; () -&gt; Int : @$s4main10SomeStructVAA0B8ProtocolA2aDP1aSivgTW	&#x2F;&#x2F; protocol witness for SomeProtocol.a.getter in conformance SomeStruct</span><br><span class="line">  method #SomeProtocol.b!getter.1: &lt;Self where Self : SomeProtocol&gt; (Self) -&gt; () -&gt; Int : @$s4main10SomeStructVAA0B8ProtocolA2aDP1bSivgTW	&#x2F;&#x2F; protocol witness for SomeProtocol.b.getter in conformance SomeStruct</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>할당되는 메모리 크기<ul>
<li><code>someStruct1</code>은 구조체 타입의 인스턴스를 나타내며 두 개의 Int 타입 프로퍼티를 가지므로 16바이트를 할당받는다.</li>
<li><code>someStruct2</code>는 프로토콜 타입의 인스턴스를 나타내며 Existential Container를 가지므로 40바이트를 할당받는다.<ul>
<li>첫 3워드는 Value Buffer로, 가지고 있는 프로퍼티의 값을 나타내고 있다.<ul>
<li>첫 8바이트에 10, 다음 8바이트에 11을 할당한다. 마지막 8바이트는 비어 있다.</li>
</ul>
</li>
<li>마지막 2워드는 VWT와 PWT의 주소를 가지고 있다.</li>
</ul>
</li>
</ul>
</li>
<li>PWT 생성<ul>
<li>컴파일러가 프로토콜을 채택하는 타입마다 PWT를 만들어 내는 것을 확인할 수 있다.</li>
</ul>
</li>
</ul>
<h5 id="3워드-초과-이하-차이로-인한-값-저장-동작-변화"><a href="#3워드-초과-이하-차이로-인한-값-저장-동작-변화" class="headerlink" title="3워드 초과 / 이하 차이로 인한 값 저장 동작 변화"></a>3워드 초과 / 이하 차이로 인한 값 저장 동작 변화</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SmallProtocol</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">  <span class="keyword">var</span> b: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">c</span>: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">LargeProtocol</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">  <span class="keyword">var</span> b: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">c</span>: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">  <span class="keyword">var</span> d: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SmallStruct</span>: <span class="title">SmallProtocol</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a: <span class="type">Int</span> = <span class="number">10</span></span><br><span class="line">  <span class="keyword">var</span> b: <span class="type">Int</span> = <span class="number">11</span></span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">c</span>: <span class="type">Int</span> = <span class="number">12</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LargeStruct</span>: <span class="title">LargeProtocol</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a: <span class="type">Int</span> = <span class="number">10</span></span><br><span class="line">  <span class="keyword">var</span> b: <span class="type">Int</span> = <span class="number">11</span></span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">c</span>: <span class="type">Int</span> = <span class="number">12</span></span><br><span class="line">  <span class="keyword">var</span> d: <span class="type">Int</span> = <span class="number">13</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> smallStruct: <span class="type">SmallProtocol</span> = <span class="type">SmallStruct</span>()</span><br><span class="line">  <span class="keyword">var</span> largeStruct: <span class="type">LargeProtocol</span> = <span class="type">LargeStruct</span>()</span><br><span class="line">  withUnsafeBytes(of: &amp;smallStruct) &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;</span><br><span class="line">  withUnsafeBytes(of: &amp;largeStruct) &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UnsafeRawBufferPointer(start: 0x00007ffeefbff488, count: 40)</span><br><span class="line">UnsafeRawBufferPointer(start: 0x00007ffeefbff460, count: 40)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">largeStruct : (7FFEEFBFF460) : 60 D1 54 00 01 00 00 00</span><br><span class="line">                               00 00 00 00 00 00 00 00</span><br><span class="line">                               00 00 00 00 00 00 00 00</span><br><span class="line">                               90 85 00 00 01 00 00 00</span><br><span class="line">                               88 84 00 00 01 00 00 00</span><br><span class="line">																								</span><br><span class="line">smallStruct : (7FFEEFBFF488) : 0A 00 00 00 00 00 00 00</span><br><span class="line">                               0B 00 00 00 00 00 00 00</span><br><span class="line">                               0C 00 00 00 00 00 00 00</span><br><span class="line">                               10 85 00 00 01 00 00 00</span><br><span class="line">                               68 84 00 00 01 00 00 00</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(10054D160) : 50 84 00 00 01 00 00 00</span><br><span class="line">              02 00 00 00 00 00 00 00</span><br><span class="line">              0A 00 00 00 00 00 00 00</span><br><span class="line">              0B 00 00 00 00 00 00 00</span><br><span class="line">              0C 00 00 00 00 00 00 00</span><br><span class="line">              0D 00 00 00 00 00 00 00</span><br></pre></td></tr></table></figure>

<ul>
<li>할당되는 메모리 크기<ul>
<li>둘 모두 프로토콜 타입이므로 40바이트를 할당받는다.</li>
</ul>
</li>
<li>3워드 초과 / 이하로 인한 차이<ul>
<li><code>smallStruct</code>는 3워드의 크기를 갖는 프로토콜을 채택하여, Existential Container의 Value Buffer에 모든 값이 저장되는 것을 확인할 수 있다.</li>
<li><code>largeStruct</code>는 4워드의 크기를 갖는 프로토콜을 채택하여, 별도의 힙 공간을 할당하여 그 곳에 모든 값을 저장하고, Existential Container에 할당된 공간의 주소를 갖는 포인터를 저장하는 것을 확인할 수 있다.</li>
</ul>
</li>
</ul>
<h5 id="3워드-초과-이하-차이로-인한-Copy-동작-변화"><a href="#3워드-초과-이하-차이로-인한-Copy-동작-변화" class="headerlink" title="3워드 초과 / 이하 차이로 인한 Copy 동작 변화"></a>3워드 초과 / 이하 차이로 인한 Copy 동작 변화</h5><h6 id="3워드-이하"><a href="#3워드-이하" class="headerlink" title="3워드 이하"></a>3워드 이하</h6><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SmallProtocol</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">  <span class="keyword">var</span> b: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">c</span>: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SmallStruct</span>: <span class="title">SmallProtocol</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a: <span class="type">Int</span> = <span class="number">10</span></span><br><span class="line">  <span class="keyword">var</span> b: <span class="type">Int</span> = <span class="number">11</span></span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">c</span>: <span class="type">Int</span> = <span class="number">12</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> bar1: <span class="type">SmallProtocol</span> = <span class="type">SmallStruct</span>()</span><br><span class="line">  <span class="keyword">var</span> bar2 = bar1</span><br><span class="line">  <span class="comment">// breakpoint 1</span></span><br><span class="line">  bar2.a = <span class="number">11</span></span><br><span class="line">  <span class="comment">// breakpoint 2</span></span><br><span class="line">  withUnsafeBytes(of: &amp;bar1) &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;</span><br><span class="line">  withUnsafeBytes(of: &amp;bar2) &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; breakpoint 1</span><br><span class="line">bar2 : (7FFEEFBFF460) : 0A 00 00 00 00 00 00 00</span><br><span class="line">                        0B 00 00 00 00 00 00 00</span><br><span class="line">                        0C 00 00 00 00 00 00 00</span><br><span class="line">                        28 85 00 00 01 00 00 00</span><br><span class="line">                        50 84 00 00 01 00 00 00</span><br><span class="line">												</span><br><span class="line">bar1 : (7FFEEFBFF488) : 0A 00 00 00 00 00 00 00</span><br><span class="line">                        0B 00 00 00 00 00 00 00</span><br><span class="line">                        0C 00 00 00 00 00 00 00</span><br><span class="line">                        28 85 00 00 01 00 00 00</span><br><span class="line">                        50 84 00 00 01 00 00 00</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; breakpoint 2</span><br><span class="line">bar2 : (7FFEEFBFF460) : 0B 00 00 00 00 00 00 00</span><br><span class="line">                        0B 00 00 00 00 00 00 00</span><br><span class="line">                        0C 00 00 00 00 00 00 00</span><br><span class="line">                        28 85 00 00 01 00 00 00</span><br><span class="line">                        50 84 00 00 01 00 00 00</span><br><span class="line">												</span><br><span class="line">bar1 : (7FFEEFBFF488) : 0A 00 00 00 00 00 00 00</span><br><span class="line">                        0B 00 00 00 00 00 00 00</span><br><span class="line">                        0C 00 00 00 00 00 00 00</span><br><span class="line">                        28 85 00 00 01 00 00 00</span><br><span class="line">                        50 84 00 00 01 00 00 00</span><br></pre></td></tr></table></figure>

<p>3워드 이하인 경우 값 전체가 그대로 복사되며, 값이 분리된다.</p>
<h6 id="3워드-초과"><a href="#3워드-초과" class="headerlink" title="3워드 초과"></a>3워드 초과</h6><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">LargeProtocol</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a: <span class="type">Int</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">  <span class="keyword">var</span> b: <span class="type">Int</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">c</span>: <span class="type">Int</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">  <span class="keyword">var</span> d: <span class="type">Int</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LargeStruct</span>: <span class="title">LargeProtocol</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a: <span class="type">Int</span> = <span class="number">10</span></span><br><span class="line">  <span class="keyword">var</span> b: <span class="type">Int</span> = <span class="number">11</span></span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">c</span>: <span class="type">Int</span> = <span class="number">12</span></span><br><span class="line">  <span class="keyword">var</span> d: <span class="type">Int</span> = <span class="number">13</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> bar1: <span class="type">LargeProtocol</span> = <span class="type">LargeStruct</span>()</span><br><span class="line">  <span class="keyword">var</span> bar2 = bar1</span><br><span class="line">  <span class="comment">// breakpoint 1</span></span><br><span class="line">  bar2.a = <span class="number">11</span></span><br><span class="line">  <span class="comment">// breakpoint 2</span></span><br><span class="line">  withUnsafeBytes(of: &amp;bar1) &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;</span><br><span class="line">  withUnsafeBytes(of: &amp;bar2) &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; breakpoint 1</span><br><span class="line"></span><br><span class="line">bar2 : (7FFEEFBFF460) : 90 B2 B3 03 01 00 00 00</span><br><span class="line">                        00 00 00 00 00 00 00 00</span><br><span class="line">                        00 00 00 00 00 00 00 00</span><br><span class="line">                        48 85 00 00 01 00 00 00</span><br><span class="line">                        80 84 00 00 01 00 00 00</span><br><span class="line"></span><br><span class="line">bar1 : (7FFEEFBFF488) : 90 B2 B3 03 01 00 00 00</span><br><span class="line">                        00 00 00 00 00 00 00 00</span><br><span class="line">                        00 00 00 00 00 00 00 00</span><br><span class="line">                        48 85 00 00 01 00 00 00</span><br><span class="line">                        80 84 00 00 01 00 00 00</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(103B3B290) : 0A 00 00 00 00 00 00 00</span><br><span class="line">              0B 00 00 00 00 00 00 00</span><br><span class="line">              0C 00 00 00 00 00 00 00</span><br><span class="line">              0D 00 00 00 00 00 00 00</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; breakpoint 2</span><br><span class="line"></span><br><span class="line">bar2 : (7FFEEFBFF460) : 70 B8 B3 03 01 00 00 00</span><br><span class="line">                        00 00 00 00 00 00 00 00</span><br><span class="line">                        00 00 00 00 00 00 00 00</span><br><span class="line">                        48 85 00 00 01 00 00 00</span><br><span class="line">                        80 84 00 00 01 00 00 00</span><br><span class="line">												</span><br><span class="line">bar1 : (7FFEEFBFF488) : 90 B2 B3 03 01 00 00 00</span><br><span class="line">                        00 00 00 00 00 00 00 00</span><br><span class="line">                        00 00 00 00 00 00 00 00</span><br><span class="line">                        48 85 00 00 01 00 00 00</span><br><span class="line">                        80 84 00 00 01 00 00 00</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(103B3B290) : 68 84 00 00 01 00 00 00</span><br><span class="line">              02 00 00 00 00 00 00 00</span><br><span class="line">              0A 00 00 00 00 00 00 00</span><br><span class="line">              0B 00 00 00 00 00 00 00</span><br><span class="line">              0C 00 00 00 00 00 00 00</span><br><span class="line">              0D 00 00 00 00 00 00 00</span><br><span class="line">							</span><br><span class="line">(103B3B870) : 78 19 B3 94 FF 7F 00 00</span><br><span class="line">              02 00 00 00 00 00 00 00</span><br><span class="line">              0B 00 00 00 00 00 00 00</span><br><span class="line">              0B 00 00 00 00 00 00 00</span><br><span class="line">              0C 00 00 00 00 00 00 00</span><br><span class="line">              0D 00 00 00 00 00 00 00</span><br></pre></td></tr></table></figure>

<p>3워드 초과인 경우 쓰기가 발생하기 전에는 동일한 힙 공간을 가리키지만, 쓰기가 발생하면 별도의 힙 공간을 할당한 후 그 곳에 값을 복사하여 Value Semantics를 구현한다.</p>
<h5 id="VWT와-PWT는-힙에-위치하는가"><a href="#VWT와-PWT는-힙에-위치하는가" class="headerlink" title="VWT와 PWT는 힙에 위치하는가?"></a>VWT와 PWT는 힙에 위치하는가?</h5><ul>
<li>DATA 섹션인 것으로 나오지만… (TODO: 힙에 있는가 데이터에 있는가?)</li>
</ul>
<h5 id="Copy-on-Write가-발생하는가"><a href="#Copy-on-Write가-발생하는가" class="headerlink" title="Copy-on-Write가 발생하는가?"></a>Copy-on-Write가 발생하는가?</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SomeProtocol</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> array: [<span class="type">Int</span>] &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SomeStruct</span>: <span class="title">SomeProtocol</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> array: [<span class="type">Int</span>] = [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> bar1: <span class="type">SomeProtocol</span> = <span class="type">SomeStruct</span>()</span><br><span class="line">  <span class="keyword">var</span> bar2 = bar1</span><br><span class="line">  <span class="comment">// breakpoint 1</span></span><br><span class="line">  bar2.array[<span class="number">0</span>] = <span class="number">9</span></span><br><span class="line">  <span class="comment">// breakpoint 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; breakpoint 1</span><br><span class="line"></span><br><span class="line">bar2 : (7FFEEFBFF468) : 50 63 8D 03 01 00 00 00</span><br><span class="line">                        00 00 00 00 00 00 00 00</span><br><span class="line">                        00 00 00 00 00 00 00 00</span><br><span class="line">                        50 74 00 00 01 00 00 00</span><br><span class="line">                        28 74 00 00 01 00 00 00</span><br><span class="line">												</span><br><span class="line">bar1 : (7FFEEFBFF490) : 50 63 8D 03 01 00 00 00</span><br><span class="line">                        00 00 00 00 00 00 00 00</span><br><span class="line">                        00 00 00 00 00 00 00 00</span><br><span class="line">                        50 74 00 00 01 00 00 00</span><br><span class="line">                        28 74 00 00 01 00 00 00</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(1038D6350) : A0 19 B3 94 FF 7F 00 00</span><br><span class="line">              02 00 00 00 02 00 00 00</span><br><span class="line">              03 00 00 00 00 00 00 00</span><br><span class="line">              06 00 00 00 00 00 00 00</span><br><span class="line">              0A 00 00 00 00 00 00 00</span><br><span class="line">              0B 00 00 00 00 00 00 00</span><br><span class="line">              0C 00 00 00 00 00 00 00</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; breakpoint 2</span><br><span class="line"></span><br><span class="line">bar2 : (7FFEEFBFF468) : D0 C2 60 00 01 00 00 00 </span><br><span class="line">                        00 00 00 00 00 00 00 00 </span><br><span class="line">                        00 00 00 00 00 00 00 00 </span><br><span class="line">                        50 74 00 00 01 00 00 00 </span><br><span class="line">                        28 74 00 00 01 00 00 00</span><br><span class="line">												</span><br><span class="line">bar1 : (7FFEEFBFF490) : 50 63 8D 03 01 00 00 00 </span><br><span class="line">                        00 00 00 00 00 00 00 00 </span><br><span class="line">                        00 00 00 00 00 00 00 00 </span><br><span class="line">                        50 74 00 00 01 00 00 00 </span><br><span class="line">                        28 74 00 00 01 00 00 00</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(10060C2D0) : A0 19 B3 94 FF 7F 00 00 </span><br><span class="line">              02 00 00 00 00 00 00 00 </span><br><span class="line">              03 00 00 00 00 00 00 00 </span><br><span class="line">              08 00 00 00 00 00 00 00 </span><br><span class="line">              09 00 00 00 00 00 00 00 </span><br><span class="line">              0B 00 00 00 00 00 00 00 </span><br><span class="line">              0C 00 00 00 00 00 00 00</span><br><span class="line"></span><br><span class="line">(1038D6350) : A0 19 B3 94 FF 7F 00 00</span><br><span class="line">              02 00 00 00 02 00 00 00</span><br><span class="line">              03 00 00 00 00 00 00 00</span><br><span class="line">              06 00 00 00 00 00 00 00</span><br><span class="line">              0A 00 00 00 00 00 00 00</span><br><span class="line">              0B 00 00 00 00 00 00 00</span><br><span class="line">              0C 00 00 00 00 00 00 00</span><br></pre></td></tr></table></figure>

<ul>
<li>breakpoint 1<ul>
<li><code>bar1</code>과 <code>bar2</code>는 프로토콜 타입이므로 각각의 Existential Container를 갖는다.</li>
<li>Array의 Indirect Storage의 주소가 복사된다. 내부 데이터가 가리키는 힙의 공간은 2의 참조 카운트를 갖는다.</li>
<li>같은 VWT와 PWT를 참조한다.</li>
</ul>
</li>
<li>breakpoint 2<ul>
<li><code>bar2</code>에 대하여 쓰기가 일어났다. 힙에 새로운 공간을 할당하여 복사한다.</li>
<li>각각의 Existential Container가 서로 다른 힙 공간을 가리키게 된다. 각각의 내부 데이터가 가리키는 힙의 공간은 1의 참조 카운트를 갖는다.</li>
<li>같은 VWT와 PWT를 참조한다.</li>
</ul>
</li>
</ul>
<p>Array는 내부적으로 Copy-on-Write를 구현해 두어 이러한 동작을 확인할 수있다.</p>
<p>하지만 개발자가 Indirect Storage를 직접 구현한다면 위에서 설명한 기법을 사용하여 Copy-on-Write를 직접 구현해 주어야 한다.</p>
<h5 id="큰-크기의-Protocol-Type-vs-Indirect-Storage"><a href="#큰-크기의-Protocol-Type-vs-Indirect-Storage" class="headerlink" title="큰 크기의 Protocol Type vs. Indirect Storage"></a>큰 크기의 Protocol Type vs. Indirect Storage</h5><ul>
<li>큰 크기의 Protocol Type<ul>
<li>내부 데이터를 힙에 저장</li>
<li>참조 카운팅을 하지 않음</li>
<li>Copy-on-Write가 구현되어 있음</li>
</ul>
</li>
<li>Indirect Storage<ul>
<li>내부 데이터를 힙에 저장</li>
<li>참조 카운팅을 함</li>
<li>Value Semantics가 필요한 경우 Copy-on-Write를 직접 구현해야 함</li>
</ul>
</li>
</ul>
<h3 id="Generic-Type"><a href="#Generic-Type" class="headerlink" title="Generic Type"></a>Generic Type</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Drawable</span> </span>&#123; <span class="function"><span class="keyword">func</span> <span class="title">draw</span><span class="params">()</span></span> &#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span>: <span class="title">Drawable</span> </span>&#123; <span class="function"><span class="keyword">func</span> <span class="title">draw</span><span class="params">()</span></span> &#123; ... &#125; &#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span>: <span class="title">Drawable</span> </span>&#123; <span class="function"><span class="keyword">func</span> <span class="title">draw</span><span class="params">()</span></span> &#123; ... &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">draw</span>&lt;T: Drawable&gt;<span class="params">(<span class="number">_</span> drawable: T)</span></span> &#123;</span><br><span class="line">  drawable.draw()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">draw(<span class="type">Point</span>())</span><br><span class="line">draw(<span class="type">Line</span>())</span><br></pre></td></tr></table></figure>

<ul>
<li>제네릭 타입 T는 Drawable 프로토콜을 채택하는 타입이어야 한다.</li>
<li>Protocol Type과 동일하게 Existential Container를 사용하며, 동작도 비슷하다.</li>
<li>하지만 메소드 내에서 <code>T</code>의 실제 타입이 결정되고 바뀌지 않는다. : 정적 다형성</li>
<li>그러므로 컴파일러가 이를 최적화할 수 있다.</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">draw</span><span class="params">(<span class="number">_</span> point: Point)</span></span> &#123;</span><br><span class="line">  point.draw()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">draw</span><span class="params">(<span class="number">_</span> line: Line)</span></span> &#123;</span><br><span class="line">  line.draw()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">draw(<span class="type">Point</span>())</span><br><span class="line">draw(<span class="type">Line</span>())</span><br></pre></td></tr></table></figure>

<ul>
<li>컴파일러는 위와 같은 코드로 최적화할 수 있다. : Generic 특수화</li>
<li>이렇게 되면 Existential Container를 사용하지 않아도 된다.</li>
<li>정적 메소드 디스패치가 되어 메소드 인라이닝 등 컴파일 타임 최적화가 가능하게 된다.</li>
</ul>
<h4 id="실험-5"><a href="#실험-5" class="headerlink" title="실험"></a>실험</h4><h5 id="정적-다형성이-구현된-것을-확인해볼-수-있을까"><a href="#정적-다형성이-구현된-것을-확인해볼-수-있을까" class="headerlink" title="정적 다형성이 구현된 것을 확인해볼 수 있을까?"></a>정적 다형성이 구현된 것을 확인해볼 수 있을까?</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SomeProtocol</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SomeStruct1</span>: <span class="title">SomeProtocol</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a: <span class="type">Int</span> = <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SomeStruct2</span>: <span class="title">SomeProtocol</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a: <span class="type">Int</span> = <span class="number">11</span></span><br><span class="line">  <span class="keyword">var</span> b: <span class="type">Int</span> = <span class="number">12</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bar</span>&lt;T: SomeProtocol&gt;<span class="params">(<span class="number">_</span> bar: T)</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> bar = bar</span><br><span class="line">  <span class="built_in">print</span>(type(of: bar))</span><br><span class="line">  withUnsafeBytes(of: &amp;bar) &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">  bar(<span class="type">SomeStruct1</span>())</span><br><span class="line">  bar(<span class="type">SomeStruct2</span>())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SomeStruct1</span><br><span class="line">UnsafeRawBufferPointer(start: 0x00007ffeefbff380, count: 8)</span><br><span class="line">SomeStruct2</span><br><span class="line">UnsafeRawBufferPointer(start: 0x00007ffeefbff380, count: 16)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(7FFEEFBFF380) : 0A 00 00 00 00 00 00 00</span><br><span class="line">(7FFEEFBFF380) : 0B 00 00 00 00 00 00 00 </span><br><span class="line">                 0C 00 00 00 00 00 00 00</span><br></pre></td></tr></table></figure>

<p>메소드 내에서 제네릭 타입은 특정 타입으로 결정되고 변하지 않는다.</p>
<p>특정 타입으로 결정되므로, 위의 코드에서는 구조체의 크기만큼 메모리에 할당된다.</p>
<h4 id="특수화되지-않은-Generics-작은-크기의-Protocol-Type"><a href="#특수화되지-않은-Generics-작은-크기의-Protocol-Type" class="headerlink" title="특수화되지 않은 Generics (작은 크기의 Protocol Type)"></a>특수화되지 않은 Generics (작은 크기의 Protocol Type)</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SmallProtocol</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SmallStruct</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a: <span class="type">Int</span> = <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span>&lt;T: SmallProtocol&gt;<span class="params">(<span class="number">_</span> bar: T)</span></span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>구분</th>
<th>내용</th>
</tr>
</thead>
<tbody><tr>
<td>메모리 할당</td>
<td>스택 (Existential Container)</td>
</tr>
<tr>
<td>참조 카운팅 발생 여부</td>
<td>false</td>
</tr>
<tr>
<td>메소드 디스패치</td>
<td>동적 (PWT)</td>
</tr>
</tbody></table>
<p>제네릭 타입이 작은 크기의 Protocol Type으로 제한되며, 특수화되지 않았다면, 작은 크기의 Protocol Type을 다루는 것처럼 동작한다.</p>
<h4 id="특수화되지-않은-Generics-큰-크기의-Protocol-Type"><a href="#특수화되지-않은-Generics-큰-크기의-Protocol-Type" class="headerlink" title="특수화되지 않은 Generics (큰 크기의 Protocol Type)"></a>특수화되지 않은 Generics (큰 크기의 Protocol Type)</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">LargeProtocol</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LargeStruct</span>: </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a: <span class="type">Int</span> = <span class="number">10</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span>&lt;T: LargeProtocol&gt;<span class="params">(<span class="number">_</span> bar: T)</span></span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>구분</th>
<th>내용</th>
</tr>
</thead>
<tbody><tr>
<td>메모리 할당</td>
<td>스택 (Existential Container, 실제 데이터는 힙)</td>
</tr>
<tr>
<td>참조 카운팅 발생 여부</td>
<td>false</td>
</tr>
<tr>
<td>메소드 디스패치</td>
<td>동적 (PWT)</td>
</tr>
</tbody></table>
<p>제네릭 타입이 큰 크기의 Protocol Type으로 제한되며, 특수화되지 않았다면, 큰 크기의 Protocol Type을 다루는 것처럼 동작한다.</p>
<h4 id="특수화된-Generic-Type-Struct"><a href="#특수화된-Generic-Type-Struct" class="headerlink" title="특수화된 Generic Type (Struct)"></a>특수화된 Generic Type (Struct)</h4><table>
<thead>
<tr>
<th>구분</th>
<th>내용</th>
</tr>
</thead>
<tbody><tr>
<td>메모리 할당</td>
<td>스택</td>
</tr>
<tr>
<td>참조 카운팅 발생 여부</td>
<td>false</td>
</tr>
<tr>
<td>메소드 디스패치</td>
<td>정적</td>
</tr>
</tbody></table>
<p>제네릭 타입을 요구하는 인자에 구조체 타입의 인스턴스를 넘기며, 특수화되었다면, 구조체를 다루는 것처럼 동작한다.</p>
<h4 id="특수화된-Generic-Type-Class"><a href="#특수화된-Generic-Type-Class" class="headerlink" title="특수화된 Generic Type (Class)"></a>특수화된 Generic Type (Class)</h4><table>
<thead>
<tr>
<th>구분</th>
<th>내용</th>
</tr>
</thead>
<tbody><tr>
<td>메모리 할당</td>
<td>힙</td>
</tr>
<tr>
<td>참조 카운팅 발생 여부</td>
<td>true</td>
</tr>
<tr>
<td>메소드 디스패치</td>
<td>동적 (V-Table)</td>
</tr>
</tbody></table>
<p>제네릭 타입을 요구하는 인자에 클래스 타입의 인스턴스를 넘기며, 특수화되었다면, 클래스를 다루는 것처럼 동작한다.</p>
<h4 id="정리-1"><a href="#정리-1" class="headerlink" title="정리"></a>정리</h4><ul>
<li>정적 다형성 (Static Polymorphism)<ul>
<li>컴파일 시점에 호출하는 곳마다 타입이 정해져 있음</li>
<li>런타임에 변경되지 않음</li>
<li>특수화 (Specialization) 가능 </li>
</ul>
</li>
</ul>
<h2 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h2><ul>
<li>Swift의 성능은 Objective-C와 비교하여 많이 향상되었다.</li>
<li>Value Type과 Protocol Type 등의 성격을 고려해야 한다. 성능 최적화를 고려하는 경우 이 내용들을 잘 써먹을 수 있을 것이다.<ul>
<li>일반적인 경우에는 고려할 필요가 없다.</li>
<li>렌더링 관련 로직 등 반복적으로 매우 빈번하게 호출되는 경우 / 서버 환경에서의 대용량 데이터 처리의 경우 이 내용을 써먹을 수 있을 것이다.</li>
</ul>
</li>
</ul>
<h3 id="추상화-기법의-선택"><a href="#추상화-기법의-선택" class="headerlink" title="추상화 기법의 선택"></a>추상화 기법의 선택</h3><ul>
<li>Struct : Value Semantics가 맞는 부분</li>
<li>Class : Identity가 맞는 부분 / 객체 지향 프로그래밍 / Objective-C 호환</li>
<li>Generics : 정적 다형성으로 처리 가능한 경우</li>
<li>Protocol : 동적 다형성이 필요한 경우</li>
</ul>
<h3 id="고려할-수-있는-성능-최적화-기법들"><a href="#고려할-수-있는-성능-최적화-기법들" class="headerlink" title="고려할 수 있는 성능 최적화 기법들"></a>고려할 수 있는 성능 최적화 기법들</h3><ul>
<li>Struct에 참조 타입 프로퍼티가 많은 경우<ul>
<li>Enum, Struct 등 Value Type으로 대체할 수 있는 방법 찾기</li>
<li>이외에 참조 카운팅을 줄일 수 있는 방법을 찾기</li>
</ul>
</li>
<li>Protocol Type을 사용하는데 대상이 크기가 큰 Struct인 경우<ul>
<li>Indirect Storage를 사용하여 Struct 구조 변경하기</li>
<li>Mutable해야 한다면 Copy-on-Write 구현하기</li>
</ul>
</li>
<li>동적 메소드 디스패치를 정적으로 할 수 있게 하기<ul>
<li>가능하면 final, private 선언을 할 수 있도록 하기</li>
<li>dynamic 사용하지 않기</li>
<li>Objective-C 연동 최소화하기</li>
<li>릴리즈 빌드에 WMO 옵션 활성화 고려하기</li>
</ul>
</li>
</ul>
<h3 id="마무리-1"><a href="#마무리-1" class="headerlink" title="마무리"></a>마무리</h3><ul>
<li>모든 경우에 반드시 적용해야 하는 것은 아니지만, 배경을 아는 것과 옳은 방향으로 향하는 것은 중요하다.</li>
</ul>
<h2 id="더-알아볼-것들"><a href="#더-알아볼-것들" class="headerlink" title="더 알아볼 것들"></a>더 알아볼 것들</h2><h3 id="Swift의-String"><a href="#Swift의-String" class="headerlink" title="Swift의 String"></a>Swift의 String</h3><ul>
<li>Swift의 String은 64비트 시스템에서 16바이트로 할당된다.<ul>
<li>String에 15바이트 이하의 스트링 리터럴을 할당하는 경우<ul>
<li>스택에 값이 바로 들어감</li>
<li>TEXT 섹션에서도 할당한 스트링 리터럴을 확인할 수 있음</li>
<li>컴파일러 최적화 : 15바이트 이하인 경우 TEXT 섹션에 스트링 리터럴 값을 저장하는 것에 더하여 스택에 바로 값을 두어 빠르게 사용할 수 있도록 함</li>
<li>Swift 4.2의 64비트에서의 small-string representation <a href="https://forums.swift.org/t/string-s-abi-and-utf-8/17676" target="_blank" rel="noopener">링크</a></li>
</ul>
</li>
<li>String에 15바이트 초과의 스트링 리터럴을 할당하는 경우<ul>
<li>뒤의 8바이트에서 맨 끝의 1바이트를 제외한 7바이트에서 스트링 리터럴이 저장된 주소를 확인할 수 있음</li>
<li>TEXT 섹션(TEXT.cstring)</li>
<li>Cocoa Internals : 스트링 리터럴 값은 TEXT 영역에 저장된다.</li>
<li>15바이트 초과인 경우 TEXT 섹션을 가리키는 포인터를 저장하고 그것을 참조하여 사용할 수 있게 한다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>Value 타입과 Reference 타입의 구분은 저장된 영역의 구분이 아닌, 오퍼랜드를 주소로 해석할 것인가 값으로 해석할 것인가의 차이일 뿐이다.<ul>
<li>이외에 Reference Type인 경우 64비트 시스템에서 주소를 저장하기 위한 8바이트의 공간을 할당받음</li>
</ul>
</li>
<li><a href="https://forums.swift.org/t/string-s-abi-and-utf-8/17676" target="_blank" rel="noopener">String’s ABI and UTF-8</a> : 2018년 11월, Swift 5 관련 내용<ul>
<li>네이티브 스위프트 문자열은 아스키이든 UTF-16이든에 상관 없이 UTF-8로 저장됨</li>
<li>UTF-8은 1바이트 유니코드 인코딩을 뜻하며 C 호환, 시스템 프로그래밍, 서버 사이드 프로그래밍, 스크립팅, 클라이언트 사이드 프로그래밍 등에 선호되는 포맷임</li>
<li>아스키와 유니코드 문자열 표현을 위한 스토리지를 통합하여 많은 성능 이점을 취할 수 있음<ul>
<li>C 호환 : C와의 호환에서 비용이 없음 (할당, 인코딩 변환 등이 없음)</li>
<li>디코딩 : 문자열을 구성하는 유니코드 스칼라 값을 디코딩하는 것이 능률적이게 됨<ul>
<li>한자의 경우 UTF-16과 비교하여 UTF-8의 디코딩 성능에 대한 가장 나쁜 케이스. UTF-16은 코드 유닛에 스칼라 값을 직접 저장하는 반면 UTF-8은 멀티바이트 인코딩 시퀀스를 저장한다.</li>
</ul>
</li>
<li>작은 UTF-8 문자열<ul>
<li>Swift 4.2에서 64비트 플랫폼에서의 작은 문자열 표현을 도입함<ul>
<li>15개의 아스키 코드 단위까지는 직접적으로 String 구조체에 저장됨 (할당이나 메모리 관리를 필요로 하지 않음)</li>
</ul>
</li>
<li>이제 UTF-8 표현과 통합되었으므로 15개의 UTF-8 단위까지 위와 같은 동작을 취할 수 있음</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0247-contiguous-strings.md" target="_blank" rel="noopener">Contiguous Strings</a></li>
<li><a href="https://swift.org/blog/utf8-string/" target="_blank" rel="noopener">UTF-8 String</a></li>
</ul>

  </div>
</article>

    <div class="blog-post-comments">
        <div id="disqus_thread">
            <noscript>Please enable JavaScript to view the comments.</noscript>
        </div>
    </div>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Posts</a></li>
         
          <li><a href="/tags/">Tag</a></li>
         
          <li><a href="/categories/">Category</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#스위프트-성능-파헤치기"><span class="toc-number">1.</span> <span class="toc-text">스위프트 성능 파헤치기</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Value-Semantics-amp-Reference-Semantics"><span class="toc-number">1.1.</span> <span class="toc-text">Value Semantics &amp; Reference Semantics</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Value-Semantics"><span class="toc-number">1.1.1.</span> <span class="toc-text">Value Semantics</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Value-Type의-특징"><span class="toc-number">1.1.2.</span> <span class="toc-text">Value Type의 특징</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#실험"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">실험</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#구조체에-Value-Type-프로퍼티가-존재할-때의-동작"><span class="toc-number">1.1.2.1.1.</span> <span class="toc-text">구조체에 Value Type 프로퍼티가 존재할 때의 동작</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#클래스에-Value-Type-프로퍼티가-존재할-때의-동작"><span class="toc-number">1.1.2.1.2.</span> <span class="toc-text">클래스에 Value Type 프로퍼티가 존재할 때의 동작</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Value-Semantics-‘값’에-의해-구분된다"><span class="toc-number">1.1.3.</span> <span class="toc-text">Value Semantics : ‘값’에 의해 구분된다</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Value-Type과-Thread"><span class="toc-number">1.1.4.</span> <span class="toc-text">Value Type과 Thread</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#복사-시-성능-문제"><span class="toc-number">1.1.5.</span> <span class="toc-text">복사 시 성능 문제?</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#실험-1"><span class="toc-number">1.1.5.1.</span> <span class="toc-text">실험</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#정해진-시간은-무엇을-의미하는-것일까"><span class="toc-number">1.1.5.1.1.</span> <span class="toc-text">정해진 시간은 무엇을 의미하는 것일까?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Array의-요소가-힙에-저장된다고"><span class="toc-number">1.1.5.1.2.</span> <span class="toc-text">Array의 요소가 힙에 저장된다고?</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reference-Type을-Immutable하게-만들면-되지-않는가"><span class="toc-number">1.1.6.</span> <span class="toc-text">Reference Type을 Immutable하게 만들면 되지 않는가?</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Immutable한-설계가-어울리지-않는-경우"><span class="toc-number">1.1.6.1.</span> <span class="toc-text">Immutable한 설계가 어울리지 않는 경우</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Immutable-객체를-갱신하기-위해-매번-새로운-객체를-만들고-할당하는-경우"><span class="toc-number">1.1.6.1.1.</span> <span class="toc-text">Immutable 객체를 갱신하기 위해 매번 새로운 객체를 만들고 할당하는 경우</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#API가-이상해지는-경우"><span class="toc-number">1.1.6.1.2.</span> <span class="toc-text">API가 이상해지는 경우</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#그래도-클래스는-중요하다"><span class="toc-number">1.1.7.</span> <span class="toc-text">그래도 클래스는 중요하다.</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#성능을-위해-고려할-것들"><span class="toc-number">1.2.</span> <span class="toc-text">성능을 위해 고려할 것들</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#메모리-할당"><span class="toc-number">1.2.1.</span> <span class="toc-text">메모리 할당</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#힙-할당-문제"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">힙 할당 문제</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#힙-할당-줄이기"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">힙 할당 줄이기</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#참조-카운팅-발생-여부"><span class="toc-number">1.2.2.</span> <span class="toc-text">참조 카운팅 발생 여부</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#참조-카운팅의-문제"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">참조 카운팅의 문제</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#실험-2"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">실험</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#참조-카운팅-직접-확인"><span class="toc-number">1.2.2.2.1.</span> <span class="toc-text">참조 카운팅 직접 확인</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#메소드-디스패치"><span class="toc-number">1.2.3.</span> <span class="toc-text">메소드 디스패치</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#정적-메소드-디스패치"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">정적 메소드 디스패치</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#메소드-인라이닝"><span class="toc-number">1.2.3.1.1.</span> <span class="toc-text">메소드 인라이닝</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#동적-메소드-디스패치"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">동적 메소드 디스패치</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#동적-메소드-디스패치의-문제"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">동적 메소드 디스패치의 문제</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Objective-C의-메소드-디스패치"><span class="toc-number">1.2.3.4.</span> <span class="toc-text">Objective-C의 메소드 디스패치</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#정적-디스패치로-강제하기"><span class="toc-number">1.2.3.5.</span> <span class="toc-text">정적 디스패치로 강제하기</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#실험-3"><span class="toc-number">1.2.3.6.</span> <span class="toc-text">실험</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#final-class-vs-class"><span class="toc-number">1.2.3.6.1.</span> <span class="toc-text">final class vs. class</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#final-class"><span class="toc-number">1.2.3.6.1.1.</span> <span class="toc-text">final class</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#class"><span class="toc-number">1.2.3.6.1.2.</span> <span class="toc-text">class</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#final-method-vs-normal-method"><span class="toc-number">1.2.3.6.2.</span> <span class="toc-text">final method vs. normal method</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#final-method"><span class="toc-number">1.2.3.6.2.1.</span> <span class="toc-text">final method</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#normal-method"><span class="toc-number">1.2.3.6.2.2.</span> <span class="toc-text">normal method</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#정리"><span class="toc-number">1.2.4.</span> <span class="toc-text">정리</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#스위프트의-추상화-기법들의-성능"><span class="toc-number">1.3.</span> <span class="toc-text">스위프트의 추상화 기법들의 성능</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Class"><span class="toc-number">1.3.1.</span> <span class="toc-text">Class</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Class-1"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">Class</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Final-Class"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">Final Class</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Struct"><span class="toc-number">1.3.2.</span> <span class="toc-text">Struct</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#참조-타입을-갖지-않는-Struct"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">참조 타입을 갖지 않는 Struct</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#참조-타입을-갖는-Struct"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">참조 타입을 갖는 Struct</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#참조-타입을-갖는-Struct가-참조-타입을-적게-갖도록-리팩토링하기"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">참조 타입을 갖는 Struct가 참조 타입을 적게 갖도록 리팩토링하기</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Protocol-Type"><span class="toc-number">1.3.3.</span> <span class="toc-text">Protocol Type</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Protocol"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">Protocol</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Protocol을-이용한-Value-Type-다형성"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">Protocol을 이용한 Value Type 다형성</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#프로토콜-타입을-사용할-때의-의문"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">프로토콜 타입을 사용할 때의 의문</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Existential-Container-정리"><span class="toc-number">1.3.3.4.</span> <span class="toc-text">Existential Container 정리</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#작은-사이즈-3워드-이하-의-Protocol-Type"><span class="toc-number">1.3.3.5.</span> <span class="toc-text">작은 사이즈(3워드 이하)의 Protocol Type</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#큰-사이즈-3워드-초과-의-Protocol-Type"><span class="toc-number">1.3.3.6.</span> <span class="toc-text">큰 사이즈(3워드 초과)의 Protocol Type</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Indirect-Storage-사용하여-개선한-큰-사이즈-Protocol-Type"><span class="toc-number">1.3.3.7.</span> <span class="toc-text">Indirect Storage 사용하여 개선한 큰 사이즈 Protocol Type</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#실험-4"><span class="toc-number">1.3.3.8.</span> <span class="toc-text">실험</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#프로토콜-타입일-때와-해당-타입일-경우의-차이는"><span class="toc-number">1.3.3.8.1.</span> <span class="toc-text">프로토콜 타입일 때와 해당 타입일 경우의 차이는?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3워드-초과-이하-차이로-인한-값-저장-동작-변화"><span class="toc-number">1.3.3.8.2.</span> <span class="toc-text">3워드 초과 &#x2F; 이하 차이로 인한 값 저장 동작 변화</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3워드-초과-이하-차이로-인한-Copy-동작-변화"><span class="toc-number">1.3.3.8.3.</span> <span class="toc-text">3워드 초과 &#x2F; 이하 차이로 인한 Copy 동작 변화</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#3워드-이하"><span class="toc-number">1.3.3.8.3.1.</span> <span class="toc-text">3워드 이하</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3워드-초과"><span class="toc-number">1.3.3.8.3.2.</span> <span class="toc-text">3워드 초과</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#VWT와-PWT는-힙에-위치하는가"><span class="toc-number">1.3.3.8.4.</span> <span class="toc-text">VWT와 PWT는 힙에 위치하는가?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Copy-on-Write가-발생하는가"><span class="toc-number">1.3.3.8.5.</span> <span class="toc-text">Copy-on-Write가 발생하는가?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#큰-크기의-Protocol-Type-vs-Indirect-Storage"><span class="toc-number">1.3.3.8.6.</span> <span class="toc-text">큰 크기의 Protocol Type vs. Indirect Storage</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Generic-Type"><span class="toc-number">1.3.4.</span> <span class="toc-text">Generic Type</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#실험-5"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">실험</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#정적-다형성이-구현된-것을-확인해볼-수-있을까"><span class="toc-number">1.3.4.1.1.</span> <span class="toc-text">정적 다형성이 구현된 것을 확인해볼 수 있을까?</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#특수화되지-않은-Generics-작은-크기의-Protocol-Type"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">특수화되지 않은 Generics (작은 크기의 Protocol Type)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#특수화되지-않은-Generics-큰-크기의-Protocol-Type"><span class="toc-number">1.3.4.3.</span> <span class="toc-text">특수화되지 않은 Generics (큰 크기의 Protocol Type)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#특수화된-Generic-Type-Struct"><span class="toc-number">1.3.4.4.</span> <span class="toc-text">특수화된 Generic Type (Struct)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#특수화된-Generic-Type-Class"><span class="toc-number">1.3.4.5.</span> <span class="toc-text">특수화된 Generic Type (Class)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#정리-1"><span class="toc-number">1.3.4.6.</span> <span class="toc-text">정리</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#마무리"><span class="toc-number">1.4.</span> <span class="toc-text">마무리</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#추상화-기법의-선택"><span class="toc-number">1.4.1.</span> <span class="toc-text">추상화 기법의 선택</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#고려할-수-있는-성능-최적화-기법들"><span class="toc-number">1.4.2.</span> <span class="toc-text">고려할 수 있는 성능 최적화 기법들</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#마무리-1"><span class="toc-number">1.4.3.</span> <span class="toc-text">마무리</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#더-알아볼-것들"><span class="toc-number">1.5.</span> <span class="toc-text">더 알아볼 것들</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Swift의-String"><span class="toc-number">1.5.1.</span> <span class="toc-text">Swift의 String</span></a></li></ol></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://presto95.github.io/2020/01/18/understanding-swift-performance/" target="_blank" rel="noopener"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://presto95.github.io/2020/01/18/understanding-swift-performance/&text=Swift 성능 이해하기" target="_blank" rel="noopener"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://presto95.github.io/2020/01/18/understanding-swift-performance/&title=Swift 성능 이해하기" target="_blank" rel="noopener"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://presto95.github.io/2020/01/18/understanding-swift-performance/&is_video=false&description=Swift 성능 이해하기" target="_blank" rel="noopener"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Swift 성능 이해하기&body=Check out this article: http://presto95.github.io/2020/01/18/understanding-swift-performance/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://presto95.github.io/2020/01/18/understanding-swift-performance/&title=Swift 성능 이해하기" target="_blank" rel="noopener"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://presto95.github.io/2020/01/18/understanding-swift-performance/&title=Swift 성능 이해하기" target="_blank" rel="noopener"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://presto95.github.io/2020/01/18/understanding-swift-performance/&title=Swift 성능 이해하기" target="_blank" rel="noopener"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://presto95.github.io/2020/01/18/understanding-swift-performance/&title=Swift 성능 이해하기" target="_blank" rel="noopener"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://presto95.github.io/2020/01/18/understanding-swift-performance/&name=Swift 성능 이해하기&description=" target="_blank" rel="noopener"><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://news.ycombinator.com/submitlink?u=http://presto95.github.io/2020/01/18/understanding-swift-performance/&t=Swift 성능 이해하기" target="_blank" rel="noopener"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2020 Presto
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Posts</a></li>
         
          <li><a href="/tags/">Tag</a></li>
         
          <li><a href="/categories/">Category</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">


<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">


    <!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>

<!-- clipboard -->

  
<script src="/lib/clipboard/clipboard.min.js"></script>

  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Disqus Comments -->

    <script type="text/javascript">
        var disqus_shortname = 'presto95';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>


</body>
</html>
