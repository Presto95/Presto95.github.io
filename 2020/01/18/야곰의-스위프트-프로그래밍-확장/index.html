<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="확장서브스크립트클래스, 구조체, 열거형에서 컬렉션, 리스트, 시퀀스 등 타입 요소에 접근하는 단축 문법 별도의 설정자, 접근자를 구현하지 않아도 인덱스를 통해 값을 설정하거나 접근할 수 있음  인덱스라고 해서 반드시 Int 타입인 것은 아님. 어떤 타입이든 사용 가능  여러 개의 서브스크립트 정의 가능 &#x2F; 다른 타입을 인덱스로 갖는 여러 개의 서브스크립트">
<meta property="og:type" content="article">
<meta property="og:title" content="야곰의 스위프트 프로그래밍 - 확장">
<meta property="og:url" content="http://presto95.github.io/2020/01/18/%EC%95%BC%EA%B3%B0%EC%9D%98-%EC%8A%A4%EC%9C%84%ED%94%84%ED%8A%B8-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%99%95%EC%9E%A5/index.html">
<meta property="og:site_name" content="Presto">
<meta property="og:description" content="확장서브스크립트클래스, 구조체, 열거형에서 컬렉션, 리스트, 시퀀스 등 타입 요소에 접근하는 단축 문법 별도의 설정자, 접근자를 구현하지 않아도 인덱스를 통해 값을 설정하거나 접근할 수 있음  인덱스라고 해서 반드시 Int 타입인 것은 아님. 어떤 타입이든 사용 가능  여러 개의 서브스크립트 정의 가능 &#x2F; 다른 타입을 인덱스로 갖는 여러 개의 서브스크립트">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-01-17T15:51:16.000Z">
<meta property="article:modified_time" content="2020-01-17T15:51:29.426Z">
<meta property="article:author" content="Presto">
<meta property="article:tag" content="swift">
<meta name="twitter:card" content="summary">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>야곰의 스위프트 프로그래밍 - 확장</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/css/rtl.css">

    
    <!-- rss -->
    
    
<meta name="generator" content="Hexo 4.2.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Posts</a></li>
         
          <li><a href="/tags/">Tag</a></li>
         
          <li><a href="/categories/">Category</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2020/01/18/Cocoa-Internals-%EA%B0%9D%EC%B2%B4/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2020/01/18/%EC%95%BC%EA%B3%B0%EC%9D%98-%EC%8A%A4%EC%9C%84%ED%94%84%ED%8A%B8-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EA%B3%BC-%EC%8A%A4%EC%9C%84%ED%94%84%ED%8A%B8/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://presto95.github.io/2020/01/18/%EC%95%BC%EA%B3%B0%EC%9D%98-%EC%8A%A4%EC%9C%84%ED%94%84%ED%8A%B8-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%99%95%EC%9E%A5/" target="_blank" rel="noopener"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://presto95.github.io/2020/01/18/%EC%95%BC%EA%B3%B0%EC%9D%98-%EC%8A%A4%EC%9C%84%ED%94%84%ED%8A%B8-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%99%95%EC%9E%A5/&text=야곰의 스위프트 프로그래밍 - 확장" target="_blank" rel="noopener"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://presto95.github.io/2020/01/18/%EC%95%BC%EA%B3%B0%EC%9D%98-%EC%8A%A4%EC%9C%84%ED%94%84%ED%8A%B8-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%99%95%EC%9E%A5/&title=야곰의 스위프트 프로그래밍 - 확장" target="_blank" rel="noopener"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://presto95.github.io/2020/01/18/%EC%95%BC%EA%B3%B0%EC%9D%98-%EC%8A%A4%EC%9C%84%ED%94%84%ED%8A%B8-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%99%95%EC%9E%A5/&is_video=false&description=야곰의 스위프트 프로그래밍 - 확장" target="_blank" rel="noopener"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=야곰의 스위프트 프로그래밍 - 확장&body=Check out this article: http://presto95.github.io/2020/01/18/%EC%95%BC%EA%B3%B0%EC%9D%98-%EC%8A%A4%EC%9C%84%ED%94%84%ED%8A%B8-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%99%95%EC%9E%A5/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://presto95.github.io/2020/01/18/%EC%95%BC%EA%B3%B0%EC%9D%98-%EC%8A%A4%EC%9C%84%ED%94%84%ED%8A%B8-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%99%95%EC%9E%A5/&title=야곰의 스위프트 프로그래밍 - 확장" target="_blank" rel="noopener"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://presto95.github.io/2020/01/18/%EC%95%BC%EA%B3%B0%EC%9D%98-%EC%8A%A4%EC%9C%84%ED%94%84%ED%8A%B8-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%99%95%EC%9E%A5/&title=야곰의 스위프트 프로그래밍 - 확장" target="_blank" rel="noopener"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://presto95.github.io/2020/01/18/%EC%95%BC%EA%B3%B0%EC%9D%98-%EC%8A%A4%EC%9C%84%ED%94%84%ED%8A%B8-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%99%95%EC%9E%A5/&title=야곰의 스위프트 프로그래밍 - 확장" target="_blank" rel="noopener"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://presto95.github.io/2020/01/18/%EC%95%BC%EA%B3%B0%EC%9D%98-%EC%8A%A4%EC%9C%84%ED%94%84%ED%8A%B8-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%99%95%EC%9E%A5/&title=야곰의 스위프트 프로그래밍 - 확장" target="_blank" rel="noopener"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://presto95.github.io/2020/01/18/%EC%95%BC%EA%B3%B0%EC%9D%98-%EC%8A%A4%EC%9C%84%ED%94%84%ED%8A%B8-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%99%95%EC%9E%A5/&name=야곰의 스위프트 프로그래밍 - 확장&description=" target="_blank" rel="noopener"><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://news.ycombinator.com/submitlink?u=http://presto95.github.io/2020/01/18/%EC%95%BC%EA%B3%B0%EC%9D%98-%EC%8A%A4%EC%9C%84%ED%94%84%ED%8A%B8-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%99%95%EC%9E%A5/&t=야곰의 스위프트 프로그래밍 - 확장" target="_blank" rel="noopener"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#확장"><span class="toc-number">1.</span> <span class="toc-text">확장</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#서브스크립트"><span class="toc-number">1.1.</span> <span class="toc-text">서브스크립트</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#상속"><span class="toc-number">1.2.</span> <span class="toc-text">상속</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#클래스-상속"><span class="toc-number">1.2.1.</span> <span class="toc-text">클래스 상속</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#재정의"><span class="toc-number">1.2.2.</span> <span class="toc-text">재정의</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#프로퍼티-재정의"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">프로퍼티 재정의</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#프로퍼티-감시자-재정의"><span class="toc-number">1.2.3.</span> <span class="toc-text">프로퍼티 감시자 재정의</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#서브스크립트-재정의"><span class="toc-number">1.2.4.</span> <span class="toc-text">서브스크립트 재정의</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#재정의-방지"><span class="toc-number">1.2.5.</span> <span class="toc-text">재정의 방지</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#클래스의-이니셜라이저-상속과-재정의"><span class="toc-number">1.3.</span> <span class="toc-text">클래스의 이니셜라이저 - 상속과 재정의</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#지정-이니셜라이저와-편의-이니셜라이저"><span class="toc-number">1.3.1.</span> <span class="toc-text">지정 이니셜라이저와 편의 이니셜라이저</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#클래스의-초기화-위임"><span class="toc-number">1.3.2.</span> <span class="toc-text">클래스의 초기화 위임</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2단계-초기화"><span class="toc-number">1.3.3.</span> <span class="toc-text">2단계 초기화</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#이니셜라이저-상속-및-재정의"><span class="toc-number">1.3.4.</span> <span class="toc-text">이니셜라이저 상속 및 재정의</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#이니셜라이저-자동-상속"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">이니셜라이저 자동 상속</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#요구-이니셜라이저"><span class="toc-number">1.3.5.</span> <span class="toc-text">요구 이니셜라이저</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#타입캐스팅"><span class="toc-number">1.4.</span> <span class="toc-text">타입캐스팅</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#기존-언어의-타입-변환과-스위프트의-타입-변환"><span class="toc-number">1.4.1.</span> <span class="toc-text">기존 언어의 타입 변환과 스위프트의 타입 변환</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#스위프트-타입캐스팅"><span class="toc-number">1.4.2.</span> <span class="toc-text">스위프트 타입캐스팅</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#데이터-타입-확인"><span class="toc-number">1.4.3.</span> <span class="toc-text">데이터 타입 확인</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#다운캐스팅"><span class="toc-number">1.4.4.</span> <span class="toc-text">다운캐스팅</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Any-AnyObject의-타입캐스팅"><span class="toc-number">1.4.5.</span> <span class="toc-text">Any, AnyObject의 타입캐스팅</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#프로토콜"><span class="toc-number">1.5.</span> <span class="toc-text">프로토콜</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#프로토콜이란"><span class="toc-number">1.5.1.</span> <span class="toc-text">프로토콜이란</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#프로토콜-요구사항"><span class="toc-number">1.5.2.</span> <span class="toc-text">프로토콜 요구사항</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#프로퍼티-요구"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">프로퍼티 요구</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#메소드-요구"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">메소드 요구</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#가변-메소드-요구"><span class="toc-number">1.5.2.3.</span> <span class="toc-text">가변 메소드 요구</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#이니셜라이저-요구"><span class="toc-number">1.5.2.4.</span> <span class="toc-text">이니셜라이저 요구</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#프로토콜의-상속-클래스-전용-프로토콜"><span class="toc-number">1.5.3.</span> <span class="toc-text">프로토콜의 상속 클래스 전용 프로토콜</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#프로토콜-조합과-프로토콜-준수-확인"><span class="toc-number">1.5.4.</span> <span class="toc-text">프로토콜 조합과 프로토콜 준수 확인</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#프로토콜의-선택적-요구"><span class="toc-number">1.5.5.</span> <span class="toc-text">프로토콜의 선택적 요구</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#프로토콜-변수와-상수"><span class="toc-number">1.5.6.</span> <span class="toc-text">프로토콜 변수와 상수</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#위임을-위한-프로토콜"><span class="toc-number">1.5.7.</span> <span class="toc-text">위임을 위한 프로토콜</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#익스텐션"><span class="toc-number">1.6.</span> <span class="toc-text">익스텐션</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#익스텐션-문법"><span class="toc-number">1.6.1.</span> <span class="toc-text">익스텐션 문법</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#익스텐션으로-추가할-수-있는-기능"><span class="toc-number">1.6.2.</span> <span class="toc-text">익스텐션으로 추가할 수 있는 기능</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#제네릭"><span class="toc-number">1.7.</span> <span class="toc-text">제네릭</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#제네릭-함수"><span class="toc-number">1.7.1.</span> <span class="toc-text">제네릭 함수</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#제네릭-타입"><span class="toc-number">1.7.2.</span> <span class="toc-text">제네릭 타입</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#제네릭-타입-확장"><span class="toc-number">1.7.3.</span> <span class="toc-text">제네릭 타입 확장</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#타입-제약"><span class="toc-number">1.7.4.</span> <span class="toc-text">타입 제약</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#프로토콜의-연관-타입"><span class="toc-number">1.7.5.</span> <span class="toc-text">프로토콜의 연관 타입</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#제네릭-서브스크립트"><span class="toc-number">1.7.6.</span> <span class="toc-text">제네릭 서브스크립트</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#프로토콜-지향-프로그래밍"><span class="toc-number">1.8.</span> <span class="toc-text">프로토콜 지향 프로그래밍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#프로토콜-초기구현"><span class="toc-number">1.8.1.</span> <span class="toc-text">프로토콜 초기구현</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#맵-필터-리듀스-직접-구현하기"><span class="toc-number">1.8.2.</span> <span class="toc-text">맵, 필터, 리듀스 직접 구현하기</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#맵"><span class="toc-number">1.8.2.1.</span> <span class="toc-text">맵</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#필터"><span class="toc-number">1.8.3.</span> <span class="toc-text">필터</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#리듀스"><span class="toc-number">1.8.4.</span> <span class="toc-text">리듀스</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#기본-타입-확장"><span class="toc-number">1.8.5.</span> <span class="toc-text">기본 타입 확장</span></a></li></ol></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        야곰의 스위프트 프로그래밍 - 확장
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Presto</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2020-01-17T15:51:16.000Z" itemprop="datePublished">2020-01-18</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        <a class="category-link" href="/categories/Swift/">Swift</a>
    </div>


      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/tags/swift/" rel="tag">swift</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h1 id="확장"><a href="#확장" class="headerlink" title="확장"></a>확장</h1><h2 id="서브스크립트"><a href="#서브스크립트" class="headerlink" title="서브스크립트"></a>서브스크립트</h2><p><strong>클래스, 구조체, 열거형에서 컬렉션, 리스트, 시퀀스 등 타입 요소에 접근하는 단축 문법</strong></p>
<p>별도의 설정자, 접근자를 구현하지 않아도 <strong>인덱스</strong>를 통해 값을 설정하거나 접근할 수 있음</p>
<ul>
<li>인덱스라고 해서 반드시 <code>Int</code> 타입인 것은 아님. 어떤 타입이든 사용 가능</li>
</ul>
<p>여러 개의 서브스크립트 정의 가능 / 다른 타입을 인덱스로 갖는 여러 개의 서브스크립트 중복 정의 가능</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">subscript</span>(<span class="number">_</span> index: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">get</span> &#123;</span><br><span class="line">        <span class="comment">// 적절한 서브스크립트 결과값 반환</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span>(newValue) &#123;</span><br><span class="line">        <span class="comment">// 적절한 설정자 역할 수행</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>newValue</code>의 타입은 서브스크립트의 반환 타입과 동일하다.</p>
<p>읽기 전용 서브스크립트를 정의하려면 <code>get</code> 키워드만 사용하여 정의하거나 키워드를 사용하지 않고 정의하면 된다.</p>
<p>인스턴스의 이름 뒤에 대괄호로 감싼 값을 써주어 사용한다. 값은 서브스크립트의 매개 변수에 정의한 타입을 가져야 한다.</p>
<h2 id="상속"><a href="#상속" class="headerlink" title="상속"></a>상속</h2><p><strong>클래스는 메소드나 프로퍼티를 다른 클래스로부터 상속받을 수 있다.</strong></p>
<p>상속받은 메소드나 프로퍼티, 서브스크립트 등을 재정의하는 것 또한 가능하다.</p>
<p>상속받은 프로퍼티에 프로퍼티 감시자를 구현할 수 있다. 그것이 연산 프로퍼티든 저장 프로퍼티든.</p>
<p>기반 클래스 : 다른 클래스로부터 상속받지 않은 클래스</p>
<h3 id="클래스-상속"><a href="#클래스-상속" class="headerlink" title="클래스 상속"></a>클래스 상속</h3><p>수직적. 기반클래스를 다른 클래스에서 물려받는 것</p>
<p>다른 클래스를 상속받으면 똑같은 기능을 구현하기 위하여 코드를 다시 작성할 필요가 없어 <strong>코드를 재사용하기 용이</strong>하고 더불어 기능을 확장할 때 기존 클래스를 변경하지 않고도 새로운 추가 기능을 정의할 수 있다.</p>
<p>자식클래스는 부모클래스의 모든 특성(인스턴스 메소드, 타입 메소드, 인스턴스 프로퍼티, 타입 프로퍼티, 서브스크립트 등)을 포함하면서 추가적인 기능을 구현할 수 있다.</p>
<p>이를 위해 클래스 디자인을 초기에 잘 하는 것이 좋겠지만… 그것이 힘들다면 리팩토링이라도 잘 하는게 중요하겠다.</p>
<h3 id="재정의"><a href="#재정의" class="headerlink" title="재정의"></a>재정의</h3><p><code>super</code> 키워드를 사용하여 부모 클래스의 특성에 접근할 수 있다.</p>
<ul>
<li>타입 메소드 내에서 부모 클래스의 타입 프로퍼티와 타입 메소드에 접근 가능</li>
<li>인스턴스 메소드 내에서 부모 클래스의 인스턴스 프로퍼티와 인스턴스 메소드, 서브스크립트에 접근 가능<ul>
<li><code>super.메소드_이름()</code></li>
<li><code>super.프로퍼티_이름</code></li>
<li><code>super[index]</code></li>
</ul>
</li>
</ul>
<h4 id="프로퍼티-재정의"><a href="#프로퍼티-재정의" class="headerlink" title="프로퍼티 재정의"></a>프로퍼티 재정의</h4><p>프로퍼티 자체를 재정의하는 것이 아님</p>
<p>프로퍼티의 접근자, 설정자, 프로퍼티 감시자 등을 재정의하는 것을 의미한다.</p>
<ul>
<li>그러므로 저장 프로퍼티로 재정의할 수는 없다.</li>
</ul>
<p>프로퍼티를 상속받은 자식클래스에서는 조상클래스의 프로퍼티의 이름과 타입만을 알 뿐, 종류(저장, 연산 등)은 알지 못하므로 재정의할 수 있는 것.</p>
<p>읽기 쓰기 모두 가능했던 연산 프로퍼티를 읽기 전용 프로퍼티로 재정의할 수 없다.</p>
<ul>
<li>읽기 전용 프로퍼티를 읽고 쓰기 모두 가능한 프로퍼티로 재정의할 수 있다.</li>
<li>읽기 쓰기 모두 가능한 프로퍼티의 설정자만 따로 재정의할 수 없다. 접근자와 설정자를 모두 재정의 해주어야 하며, 이 경우 접근자에서 특별한 기능 변경이 없다면 <code>super.프로퍼티_이름</code>을 반환해주면 된다.</li>
</ul>
<h3 id="프로퍼티-감시자-재정의"><a href="#프로퍼티-감시자-재정의" class="headerlink" title="프로퍼티 감시자 재정의"></a>프로퍼티 감시자 재정의</h3><p>조상클래스에 정의한 프로퍼티가 연산 프로퍼티인지 저장 프로퍼티인지는 상관 없다.</p>
<ul>
<li>상수 저장 프로퍼티, 읽기 전용 연산 프로퍼티의 경우 프로퍼티 감시자 재정의가 불가능하다.<ul>
<li>상수 저장 프로퍼티는 값이 바뀔 일이 없음</li>
<li>읽기 전용 연산 프로퍼티는 설정자가 없으므로 값을 설정할 수 없음</li>
</ul>
</li>
</ul>
<p>프로퍼티 감시자를 재정의하더라도 조상클래스에 정의한 프로퍼티 감시자도 동작한다.</p>
<p>프로퍼티의 접근자와 프로퍼티 감시자는 동시에 재정의할 수 없으며, 재정의하는 접근자에 프로퍼티 감시자 역할을 구현해야 한다.</p>
<h3 id="서브스크립트-재정의"><a href="#서브스크립트-재정의" class="headerlink" title="서브스크립트 재정의"></a>서브스크립트 재정의</h3><p>서브스크립트도 매개변수와 반환형이 다르면 다른 서브스크립트로 취급되므로 자식클래스에서 재정의하려는 서브스크립트는 부모클래스의 서브스크립트의 매개변수와 반환타입과 같아야 한다.</p>
<p>다만 자동완성이 안되는 것에 주의하자.</p>
<h3 id="재정의-방지"><a href="#재정의-방지" class="headerlink" title="재정의 방지"></a>재정의 방지</h3><p><code>final</code> 키워드를 명시하여 재정의를 할 수 없도록 제한할 수 있다.</p>
<ul>
<li><code>final class 클래스명</code>과 같이 정의된 클래스는 상속되거나 재정의될 수 없다.</li>
</ul>
<h2 id="클래스의-이니셜라이저-상속과-재정의"><a href="#클래스의-이니셜라이저-상속과-재정의" class="headerlink" title="클래스의 이니셜라이저 - 상속과 재정의"></a>클래스의 이니셜라이저 - 상속과 재정의</h2><p>값 타입의 이니셜라이저는 상속을 고려할 필요가 없었으나 클래스는 상속이 가능하므로 상속받았을 때 이니셜라이저를 어떻게 재정의하는지도 중요하다.</p>
<p>두 종류의 이니셜라이저가 존재하고, 다양한 패턴의 이니셜라이저가 생길 수 있어 클래스 디자인에 더 많은 고민이 필요하다.</p>
<h3 id="지정-이니셜라이저와-편의-이니셜라이저"><a href="#지정-이니셜라이저와-편의-이니셜라이저" class="headerlink" title="지정 이니셜라이저와 편의 이니셜라이저"></a>지정 이니셜라이저와 편의 이니셜라이저</h3><p><strong>지정 이니셜라이저</strong></p>
<ul>
<li>주요 이니셜라이저. 일반적인 의미의 이니셜라이저</li>
<li>이니셜라이저가 정의된 클래스의 모든 프로퍼티를 초기화해야함</li>
<li>클래스에 하나 이상 정의함</li>
<li>조상클래스에 정의된 지정 이니셜라이저가 자손클래스의 지정 이니셜라이저 역할을 충분히 해낸다면 자손클래스는 지정 이니셜라이저를 갖지 않을 수 있음<ul>
<li>자손클래스에서 새로 선언한 프로퍼티가 옵셔널 타입일 때 등의 경우</li>
</ul>
</li>
</ul>
<p><strong>편의 이니셜라이저</strong></p>
<ul>
<li><code>convenience</code> 키워드를 <code>init</code> 앞에 명시하여 편의 이니셜라이저 정의</li>
<li>초기화를 좀 더 쉽게 할 수 있도록 도와주는 역할</li>
<li>지정 이니셜라이저를 내부에서 호출<ul>
<li>부모클래스의 이니셜라이저를 호출할 수 없음</li>
</ul>
</li>
<li>클래스 설계자의 의도대로 외부에서 사용하길 원하거나 인스턴스 생성 코드를 작성하는 수고를 덜 때 유용하게 사용 가능</li>
</ul>
<h3 id="클래스의-초기화-위임"><a href="#클래스의-초기화-위임" class="headerlink" title="클래스의 초기화 위임"></a>클래스의 초기화 위임</h3><ul>
<li>자식클래스의 <strong>지정 이니셜라이저</strong>는 부모클래스의 <strong>지정 이니셜라이저</strong>를 반드시 호출해야 한다.</li>
<li><strong>편의 이니셜라이저</strong>는 자신을 정의한 클래스의 다른 <strong>이니셜라이저</strong>를 반드시 호출해야 한다.</li>
<li><strong>편의 이니셜라이저</strong>는 궁극적으로는 <strong>지정 이니셜라이저</strong>를 반드시 호출해야 한다.</li>
</ul>
<blockquote>
<p>어떤 이니셜라이저는 지정 이니셜라이저에게 초기화를 반드시 위임한다.</p>
<p>편의 이니셜라이저는 어떤 이니셜라이저에게 초기화를 반드시 위임한다.</p>
</blockquote>
<h3 id="2단계-초기화"><a href="#2단계-초기화" class="headerlink" title="2단계 초기화"></a>2단계 초기화</h3><p>Swift에서 클래스 초기화는 2단계로 이루어진다.</p>
<ul>
<li>프로퍼티를 초기화하기 전에 프로퍼티 값에 접근하는 것을 막아 초기화를 안전하게 할 수 있게 함</li>
<li>다른 이니셜라이저가 프로퍼티의 값을 변경하는 것을 방지함</li>
</ul>
<p><strong>안전확인</strong></p>
<ul>
<li>자식클래스의 지정 이니셜라이저가 부모클래스의 이니셜라이저를 호출하기 전에 자신의 프로퍼티를 모두 초기화했는지 확인</li>
<li>자식클래스의 지정 이니셜라이저는 상속받은 프로퍼티에 값을 할당하기 전에 반드시 부모클래스의 이니셜라이저를 호출해야 함<ul>
<li>부모클래스의 이니셜라이저가 부모클래스의 프로퍼티 값을 초기화할 가능성이 있음</li>
</ul>
</li>
<li>편의 이니셜라이저는 자신의 클래스에 정의한 프로퍼티를 포함하여 그 어떤 프로퍼티라도 값을 할당하기 전에 다른 이니셜라이저를 호출해야 함<ul>
<li>클래스 내에 있는 다른 이니셜라이저가 프로퍼티 값을 초기화할 가능성이 있음</li>
</ul>
</li>
<li>초기화 1단계를 마치기 전까지 이니셜라이저는 인스턴스 메소드를 호출할 수 없음. 인스턴스 프로퍼티의 값을 읽어들일 수도없음. <code>self</code> 프로퍼티를 자신의 인스턴스를 나타내는 값으로 활용할 수 없음</li>
</ul>
<p>클래스의 인스턴스는 초기화 1단계를 마치기 전에는 유효하지 않다. 1단계를 마쳐야 비로소 유효한 인스턴스가 된다.</p>
<p><strong>1단계</strong></p>
<ol>
<li>클래스가 지정 또는 편의 이니셜라이저를 호출함</li>
<li>해당 클래스의 새로운 인스턴스를 위한 메모리가 할당됨. 그 메모리는 아직 초기화되지 않은 상태</li>
<li>지정 이니셜라이저는 클래스에 정의된 모든 저장 프로퍼티에 값이 있는지 확인. 현재 클래스 부분까지의 저장 프로퍼티를 위한 메모리가 초기화됨</li>
<li>지정 이니셜라이저는 부모클래스의 이니셜라이저가 같은 동작을 행할 수 있도록 초기화를 양도함</li>
<li>부모클래스는 상속 체인을 따라 최상위 클래스에 도달할 때까지 이 작업을 반복<ul>
<li>최상위 클래스에 도달했을 때 최상위 클래스까지 모든 저장 프로퍼티에 값이 있다고 확인하면 해당 인스턴스의 메모리는 모두 초기화된 것이고, 이로써 1단계가 완료됨</li>
</ul>
</li>
</ol>
<p>호출한 클래스에서 최상위 클래스까지 안전확인을 거치며 거슬러 올라감</p>
<p><strong>2단계</strong></p>
<ol>
<li>최상위 클래스로부터 최하위 클래스까지 상속 체인을 따라 내려오면서 지정 이니셜라이저들이 인스턴스를 제각각 사용자 정의함. 이 단계에서 <code>self</code>를 통해 프로퍼티 값을 수정할 수 있고, 인스턴스 메소드를 호출하는 등의 작업을 진행할 수 있음</li>
<li>마지막으로 각각의 편의 이니셜라이저를 통해 <code>self</code>를 통한 사용자 정의 작업을 진행할 수 있음</li>
</ol>
<p>1단계를 통해 도달한 최상위 클래스에서 사용자 정의를 하고, 아래로 내려가면서 사용자 정의함</p>
<h3 id="이니셜라이저-상속-및-재정의"><a href="#이니셜라이저-상속-및-재정의" class="headerlink" title="이니셜라이저 상속 및 재정의"></a>이니셜라이저 상속 및 재정의</h3><p>기본적으로 <strong>Swift의 이니셜라이저는 부모클래스의 이니셜라이저를 상속받지 않는다.</strong> 부모클래스의 이니셜라이저는 자식클래스에 최적화되어 있지 않기 때문이며, 최적화되었다고 판단되는 특정 상황에서는 부모클래스의 이니셜라이저가 상속되기도 한다.</p>
<p>부모클래스의 이니셜라이저와 동일한 이니셜라이저를 자식클래스에서 사용하려면 재정의하여 구현한다.</p>
<p>부모클래스의 편의 이니셜라이저와 동일한 이니셜라이저를 자식클래스에서 구현하려면 <code>override</code> 키워드를 명시하지 않는다. 편의 이니셜라이저는 부모클래스의 이니셜라이저를 호출할 수 없기 때문이다.</p>
<p>부모클래스의 실패 가능한 이니셜라이저(<code>init?</code>)를 자식 클래스에서 재정의하고 싶을 때는 필요에 따라서 실패하지 않는 이니셜라이저로 재정의할 수 있다.</p>
<h4 id="이니셜라이저-자동-상속"><a href="#이니셜라이저-자동-상속" class="headerlink" title="이니셜라이저 자동 상속"></a>이니셜라이저 자동 상속</h4><p>자식클래스에서 프로퍼티 기본값을 모두 제공한다고 가정할 때,</p>
<ul>
<li>자식클래스에서 별도의 지정 이니셜라이저를 구현하지 않는다면 부모클래스의 지정 이니셜라이저가 자동 상속됨<ul>
<li>자식클래스에서 자신만의 지정 이니셜라이저를 구현하였다면, 부모클래스의 지정 이니셜라이저는 자동 상속되지 않음</li>
</ul>
</li>
<li>위의 규칙에 따라 자식클래스가 부모클래스의 지정 이니셜라이저를 자동 상속받은 경우, 또는 부모클래스의 지정 이니셜라이저를 모두 재정의하여 부모클래스와 동일한 지정 이니셜라이저를 모두 사용할 수 있는 상황이라면, 부모 클래스의 편의 이니셜라이저가 자동 상속됨</li>
</ul>
<h3 id="요구-이니셜라이저"><a href="#요구-이니셜라이저" class="headerlink" title="요구 이니셜라이저"></a>요구 이니셜라이저</h3><p><code>required</code> 키워드를 클래스의 이니셜라이저 앞에 명시하여 해당 클래스를 상속받은 자식클래스가 반드시 해당 이니셜라이저를 재정의해주어야 한다. 이 경우 재정의하는 부분에서 <code>override</code> 키워드가 아닌 <code>required</code> 키워드를 사용하여 재정의한다.</p>
<p><code>UIView</code>에서 이니셜라이저를 재정의할 때 <code>init(frame:)</code>을 재정의해주면 <code>init(coder:)</code>도 재정의해주어야 함. 자식클래스에서 별도의 지정 이니셜라이저를 구현해주어 이니셜라이저 자동 상속이 이루어지지 않고, <code>init(coder:)</code>는 요구 이니셜라이저이기 때문이다.</p>
<p>부모클래스의 이니셜라이저를 자신의 클래스에서 요구 이니셜라이저로 변경할 수 있으며, 이 경우 <code>required override</code> 키워드를 명시한다.</p>
<p>편의 이니셜라이저도 <code>required convenience</code> 키워드로 요구 편의 이니셜라이저가 되게 할 수 있다.</p>
<h2 id="타입캐스팅"><a href="#타입캐스팅" class="headerlink" title="타입캐스팅"></a>타입캐스팅</h2><p>Swift는 강타입 언어. 데이터 타입 안전을 위해 각기 다른 타입끼리의 값 교환을 엄격하게 제한한다. 암시적 형변환 또한 지원하지 않는다.</p>
<h3 id="기존-언어의-타입-변환과-스위프트의-타입-변환"><a href="#기존-언어의-타입-변환과-스위프트의-타입-변환" class="headerlink" title="기존 언어의 타입 변환과 스위프트의 타입 변환"></a>기존 언어의 타입 변환과 스위프트의 타입 변환</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">"13"</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="type">Int</span>(a)</span><br></pre></td></tr></table></figure>

<p>위의 코드의 <code>Int(a)</code>은 타입캐스팅 또는 형변환이 아니다. <code>Int</code>는 구조체로 정의되어 있고, 새로운 구조체 인스턴스를 생성하는 것이다.</p>
<p><code>b</code>는 <code>Int?</code>형을 갖고, 이 경우 실패 가능한 이니셜라이저로 구현되어 있음을 알 수 있다.</p>
<h3 id="스위프트-타입캐스팅"><a href="#스위프트-타입캐스팅" class="headerlink" title="스위프트 타입캐스팅"></a>스위프트 타입캐스팅</h3><p><strong>Swift의 타입캐스팅은 인스턴스의 타입을 확인하거나 자신을 다른 타입의 인스턴스인 것처럼 행세할 수 있는 방법으로 사용할 수 있다.</strong></p>
<p><code>is</code> 연산자와 <code>as</code> 연산자로 구현됨 : 값의 타입을 확인하거나 다른 타입으로 전환할 수 있음, 프로토콜을 준수하는지 확인할 수 있음</p>
<p>참조 타입에서 주로 사용됨</p>
<h3 id="데이터-타입-확인"><a href="#데이터-타입-확인" class="headerlink" title="데이터 타입 확인"></a>데이터 타입 확인</h3><p><strong><code>is</code> 연산자를 사용하여 인스턴스가 어떤 클래스 (혹은 어떤 클래스의 자식클래스)의 인스턴스인지 확인할 수 있음</strong></p>
<p>모든 데이터 타입에 사용 가능</p>
<p><strong>메타 타입 타입</strong></p>
<ul>
<li>타입의 타입. 타입 자체가 하나의 타입으로 또 표현할 수 있음</li>
<li>타입의 이름 뒤에 <code>.Type</code>를 붙여 메타 타입을 나타냄<ul>
<li>프로토콜의 경우 프로토콜 이름 뒤에 <code>.Protocol</code>을 붙여 프로토콜의 메타 타입을 나타냄</li>
</ul>
</li>
<li>타입의 이름 뒤에 <code>.self</code>를 붙여 타입을 값으로 표현한 값을 반환</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Protocol</span> </span>&#123; &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Class</span>: <span class="title">Protocol</span> </span>&#123; &#125;</span><br><span class="line"><span class="keyword">let</span> intType: <span class="type">Int</span>.<span class="type">Type</span> = <span class="type">Int</span>.<span class="keyword">self</span></span><br><span class="line"><span class="keyword">let</span> classType: <span class="type">Class</span>.<span class="type">Type</span> = <span class="type">Class</span>.<span class="keyword">self</span></span><br><span class="line"><span class="keyword">let</span> protocolType: <span class="type">Protocol</span>.<span class="type">Protocol</span> = <span class="type">Protocol</span>.<span class="keyword">self</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>type(of:)</code> 함수를 사용하여 인스턴스의 타입을 표현한 값을 구할 수 있음<ul>
<li><code>type(of: someInstance).self</code>와 같이 작성하여 <code>someInstance</code>의 타입을 값으로 표현한 값을 반환</li>
</ul>
</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>.<span class="keyword">self</span>			<span class="comment">// a는 Int 타입</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="type">String</span>.<span class="keyword">self</span>		<span class="comment">// b는 String.Type 타입 (String 메타 타입 타입)</span></span><br><span class="line"><span class="built_in">print</span>(a)	<span class="comment">// 1</span></span><br><span class="line"><span class="built_in">print</span>(b)	<span class="comment">// String</span></span><br></pre></td></tr></table></figure>

<h3 id="다운캐스팅"><a href="#다운캐스팅" class="headerlink" title="다운캐스팅"></a>다운캐스팅</h3><p><strong><code>as</code> 연산자를 사용하여 자식클래스보다 더 상위에 있는 부모클래스의 타입을 자식클래스의 타입으로 캐스팅</strong></p>
<p><code>as?</code> 연산자는 다운캐스팅 실패시 <code>nil</code>을 반환하고 성공시 옵셔널 타입의 인스턴스를 반환</p>
<p><code>as!</code> 연산자는 다운캐스팅 실패시 런타임 에러를 발생시키고 성공시 해당 타입의 인스턴스를 반환</p>
<p><code>as</code> 연산자는 컴파일러가 다운캐스팅이 성공할 것임을 확신할 때 사용 가능</p>
<ul>
<li>캐스팅하려는 타입이 같은 타입이거나 부모클래스 타입</li>
</ul>
<blockquote>
<p>캐스팅은 실제로 인스턴스를 수정하거나 값은 변경하는 작업이 아님. 인스턴스는 메모리에 똑같이 남아 있음</p>
<p>인스턴스를 사용할 때 어떤 타입으로 다루고 접근해야 하는지 판단하는 것을 도와주는 것</p>
</blockquote>
<h3 id="Any-AnyObject의-타입캐스팅"><a href="#Any-AnyObject의-타입캐스팅" class="headerlink" title="Any, AnyObject의 타입캐스팅"></a>Any, AnyObject의 타입캐스팅</h3><p><code>Any</code>는 함수 타입을 포함한 모든 타입을 뜻함</p>
<p><code>AnyObject</code>는 클래스 타입만을 뜻함</p>
<p>가령 API를 사용할 때 반환 타입이 <code>Any</code>나 <code>AnyObject</code>라면, 이것이 어떤 데이터 타입인지 확인하고 사용해야 할 필요가 있다.</p>
<p><code>is</code> 연산자나 <code>as</code> 연산자 등으로 데이터 타입을 확인하고, 적절하게 처리하여 사용 가능하다.</p>
<h2 id="프로토콜"><a href="#프로토콜" class="headerlink" title="프로토콜"></a>프로토콜</h2><p><strong>Swift의 Protocol Oriented Programming을 실현하기 위한 수단</strong></p>
<h3 id="프로토콜이란"><a href="#프로토콜이란" class="headerlink" title="프로토콜이란"></a>프로토콜이란</h3><p><strong>특정 역할을 하기 위한 메소드, 프로퍼티, 기타 요구사항 등의 청사진</strong></p>
<p>구조체, 열거형, 클래스는 프로토콜을 채택하여 특정 기능을 실행하기 위한 프로토콜의 요구사항을 실제로 구현할 수 있음</p>
<p>프로토콜 준수 : 어떤 프로토콜의 요구사항을 모두 따르는 타입은 해당 프로토콜을 준수한다.</p>
<p>프로토콜은 정의를 하고 제시를 할 뿐 스스로 기능을 구현하지는 않는다.</p>
<h3 id="프로토콜-요구사항"><a href="#프로토콜-요구사항" class="headerlink" title="프로토콜 요구사항"></a>프로토콜 요구사항</h3><h4 id="프로퍼티-요구"><a href="#프로퍼티-요구" class="headerlink" title="프로퍼티 요구"></a>프로퍼티 요구</h4><p><strong>프로토콜은 자신을 채택한 타입이 어떤 프로퍼티를 구현해야 하는지 요구할 수 있음</strong></p>
<p>프로토콜은 그 프로퍼티의 종류는 신경쓰지 않고, 다만 프로토콜을 채택한 타입이 프로퍼티의 이름과 타입만 맞도록 구현해주면 됨</p>
<p>프로퍼티를 읽기 전용으로 할지 읽고 쓰기가 모두 가능하게 할지는 프로토콜이 결정해야 함</p>
<p><code>var</code> 키워드를 사용한 변수 프로퍼티로 정의</p>
<ul>
<li>읽고 쓰기가 모두 가능한 프로퍼티에는 프로퍼티의 정의 뒤에 <code>{ get set }</code>을 명시</li>
<li>읽기 전용 프로퍼티에는 프로퍼티의 정의 뒤에 <code>{ get }</code>을 명시</li>
</ul>
<p>타입 프로퍼티를 요구하기 위해 <code>static</code> 키워드를 사용하여 정의.</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Protocol</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 이 프로토콜을 채택한 타입은 상수 저장 프로퍼티나 읽기 전용 연산 프로퍼티, 읽고 쓰기가 모두 가능한 연산 프로퍼티로 구현 가능</span></span><br><span class="line">    <span class="keyword">var</span> property1: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="comment">// 이 프로토콜을 채택한 타입은 읽고 쓰기가 모두 가능한 연산 프로퍼티로 구현 가능</span></span><br><span class="line">    <span class="keyword">var</span> property2: <span class="type">Int</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> property3: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> property4: <span class="type">Int</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="메소드-요구"><a href="#메소드-요구" class="headerlink" title="메소드 요구"></a>메소드 요구</h4><p><strong>프로토콜은 자신을 채택한 타입이 어떤 인스턴스 메소드나 타입 메소드를 구현해야 하는지 요구할 수 있음</strong></p>
<p>실제 구현부인 중괄호 부분은 제외. 메소드 이름, 반환형, 매개변수 등만 작성. 가변 매개변수 허용</p>
<p>매개변수 기본값을 지정할 수 없음</p>
<p>타입 메소드를 요구하기 위해 <code>static</code> 키워드를 사용하여 정의. 실제 구현시 <code>static</code>과 <code>class</code> 키워드 중 어느 것을 사용하여 구현해 주어도 무방함</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Protocol</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">method1</span><span class="params">(data: <span class="keyword">Any</span>)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">method2</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">method3</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>프로토콜 타입의 인스턴스는 해당 프로토콜을 준수하는 타입의 인스턴스라고 생각할 수 있음</p>
<blockquote>
<p>델리게이트 패턴을 구현할 때 프로토콜 타입의 변수에 해당 프로토콜을 준수하는 인스턴스를 할당할 수 있음</p>
<p><code>tableView.delegate = self</code></p>
</blockquote>
<h4 id="가변-메소드-요구"><a href="#가변-메소드-요구" class="headerlink" title="가변 메소드 요구"></a>가변 메소드 요구</h4><p>메소드가 값 타입 인스턴스 내부의 값을 변경하려고 할 때 <code>mutating</code> 키워드를 명시하여 메소드가 인스턴스 내부의 값을 변경한다는 것을 확실히 해줌</p>
<p>클래스(참조 타입 인스턴스) 구현에서는 <code>mutating</code> 키워드를 명시하지 않아도 됨.</p>
<p>값 타입 인스턴스 구현에서는 <code>mutating</code> 키워드를 명시해 주어야 함</p>
<h4 id="이니셜라이저-요구"><a href="#이니셜라이저-요구" class="headerlink" title="이니셜라이저 요구"></a>이니셜라이저 요구</h4><p><strong>프로토콜은 자신을 채택한 타입이 준수할 특정 이니셜라이저를 요구할 수 있음</strong></p>
<p>이니셜라이저의 매개변수를 지정할 뿐, 중괄호를 포함한 이니셜라이저 구현은 프로토콜 내에서 이루어지지 않음</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Protocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>클래스 타입에서 위 프로토콜이 요구하는 이니셜라이저를 구현할 때 이니셜라이저가 지정 이니셜라이저인지 편의 이니셜라이저인지는 중요하지 않음</p>
<ul>
<li>그러나 <code>required</code> 키워드를 명시하여 요구 이니셜라이저로 구현해주어야 함<ul>
<li>프로토콜이 이니셜라이저 구현을 요구함</li>
<li>클래스가 <code>final</code> 키워드로 상속받을 수 없는 클래스로 정의되었다면 <code>required</code> 식별자를 명시할 필요가 없음</li>
</ul>
</li>
<li>특정 클래스에 프로토콜이 요구하는 이니셜라이저가 이미 구현되어 있는 상황에서 해당 클래스를 상속받은 클래스가 프로토콜을 준수하려 한다면, <code>required override</code> 키워드를 명시하여 프로토콜이 요구하는 이니셜라이저를 구현해 주어야 함</li>
</ul>
<p>프로토콜은 실패 가능한 이니셜라이저를 요구할 수 있으며, 이 때 프로토콜을 준수하는 타입은 이것을 실패 가능한 이니셜라이저로, 실패하지 않는 이니셜라이저로 구현해도 무방함</p>
<h3 id="프로토콜의-상속-클래스-전용-프로토콜"><a href="#프로토콜의-상속-클래스-전용-프로토콜" class="headerlink" title="프로토콜의 상속 클래스 전용 프로토콜"></a>프로토콜의 상속 클래스 전용 프로토콜</h3><p>프로토콜은 하나 이상의 프로토콜을 상속받아 기존 프로토콜의 요구사항보다 더 많은 요구사항을 추가할 수 있음</p>
<p>프로토콜의 상속 리스트의 맨 처음에 <code>class</code> 키워드를 추가하여 프로토콜이 클래스 타입에만 채택될 수 있도록 제한할 수 있음</p>
<ul>
<li>델리게이트 패턴을 구현하기 위한 프로토콜이 위와 같이 정의되는 예시</li>
</ul>
<h3 id="프로토콜-조합과-프로토콜-준수-확인"><a href="#프로토콜-조합과-프로토콜-준수-확인" class="headerlink" title="프로토콜 조합과 프로토콜 준수 확인"></a>프로토콜 조합과 프로토콜 준수 확인</h3><p>하나의 매개변수가 여러 프로토콜을 모두 준수하는 타입이어야 한다면 하나의 매개변수에 여러 프로토콜을 한번에 조합하여 요구할 수 있고, 하나의 매개변수가 프로토콜을 둘 이상 요구할 수 있음</p>
<ul>
<li><code>&amp;</code> 연산자로 프로토콜을 조합하여 표현함</li>
</ul>
<p>특정 클래스와 프로토콜을 조합하여 클래스의 인스턴스 역할을 할 수 있는지 함께 확인할 수 있다.</p>
<ul>
<li>구조체, 열거형 타입은 조합할 수 없음</li>
<li>클래스 타입은 단 한 가지 타입만 조합할 수 있음</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 인자에 SomeProtocol과 AnotherProtocol 프로토콜을 모두 준수하는 것만 넣을 수 있음</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">function</span><span class="params">(<span class="number">_</span> a: SomeProtocol &amp; AnotherProtocol)</span></span></span><br><span class="line"><span class="comment">// Class의 인스턴스 역할을 수행하며, SomeProtocol과 AnotherProtocol 프로토콜을 모두 준수하는 인스턴스만 할당 가능</span></span><br><span class="line"><span class="keyword">var</span> variable: <span class="type">Class</span> &amp; <span class="type">SomeProtocol</span> &amp; <span class="type">AnotherProtocol</span></span><br></pre></td></tr></table></figure>

<p><code>is</code>와 <code>as</code> 연산자를 사용하여 대상이 프로토콜을 준수하는지 확인할 수 있고, 특정 프로토콜로 캐스팅할 수 있음</p>
<ul>
<li>프로토콜도 하나의 타입이므로 프로토콜로 캐스팅 가능함</li>
</ul>
<h3 id="프로토콜의-선택적-요구"><a href="#프로토콜의-선택적-요구" class="headerlink" title="프로토콜의 선택적 요구"></a>프로토콜의 선택적 요구</h3><p>먼저 <code>@objc</code> 속성을 명시하여 해당 프로토콜을 Objective-C에서 사용 가능하도록 만들어야 한다.</p>
<p>이후 프로퍼티나 메소드 정의 시 <code>optional</code> 키워드를 명시하여 선택적으로 요구할 수 있는 프로퍼티나 메소드를 정의한다.</p>
<ul>
<li>이 경우 프로퍼티나 메소드의 타입 자체가 옵셔널이 됨</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@objc</span> <span class="class"><span class="keyword">protocol</span> <span class="title">Protocol</span> </span>&#123;</span><br><span class="line">    <span class="meta">@objc</span> <span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">fly</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Class</span>: <span class="title">NSObject</span>, <span class="title">Protocol</span> </span>&#123; &#125;</span><br><span class="line"><span class="keyword">let</span> a = <span class="type">Class</span>()</span><br><span class="line"><span class="comment">// 선택적 요구사항인 메소드를 호출하므로 옵셔널 체인을 이용하여 호출. 응답 없음</span></span><br><span class="line">a.fly?()</span><br></pre></td></tr></table></figure>

<h3 id="프로토콜-변수와-상수"><a href="#프로토콜-변수와-상수" class="headerlink" title="프로토콜 변수와 상수"></a>프로토콜 변수와 상수</h3><p>프로토콜은 프로토콜 이름만으로 자기 스스로 인스턴스를 생성하고 초기화할 수 없다.</p>
<p>하지만 특정 프로토콜을 준수하는 타입의 인스턴스를 할당할 수는 있다.</p>
<h3 id="위임을-위한-프로토콜"><a href="#위임을-위한-프로토콜" class="headerlink" title="위임을 위한 프로토콜"></a>위임을 위한 프로토콜</h3><p><strong>Delegation</strong> : 클래스나 구조체가 자신의 책임이나 임무를 다른 타입의 인스턴스에게 위임하는 디자인 패턴</p>
<p>책무를 위임. 다른 인스턴스에게 자신이 해야 할 일을 위임.</p>
<p>사용자의 특정 행동에 반응하기 위해 사용되기도 하며, 비동기 처리에도 많이 사용함</p>
<h2 id="익스텐션"><a href="#익스텐션" class="headerlink" title="익스텐션"></a>익스텐션</h2><p><strong>익스텐션 기능으로 구조체, 클래스, 열거형, 프로토콜 타입에 새로운 기능을 추가할 수 있음</strong></p>
<ul>
<li>연산 타입 프로퍼티 / 연산 인스턴스 프로퍼티</li>
<li>타입 메소드 / 인스턴스 메소드</li>
<li>이니셜라이저</li>
<li>서브스크립트</li>
<li>중첩 타입</li>
<li>특정 프로토콜을 준수할 수 있도록 기능 추가</li>
</ul>
<p>익스텐션은 타입에 새로운 기능을 추가하는 것. 기존에 존재하는 기능을 재정의할 수 없음</p>
<table>
<thead>
<tr>
<th></th>
<th>상속</th>
<th>익스텐션</th>
</tr>
</thead>
<tbody><tr>
<td>확장</td>
<td>수직적</td>
<td>수평적</td>
</tr>
<tr>
<td>사용</td>
<td>클래스</td>
<td>클래스 / 구조체 / 열거형 / 프로토콜 / 제네릭 등 모든 타입</td>
</tr>
<tr>
<td>재정의</td>
<td>재정의 가능</td>
<td>재정의 불가능</td>
</tr>
</tbody></table>
<p>외부에서 가져온 타입에 내가 원하는 기능을 추가하려 할 때 익스텐션을 활용할 수 있음</p>
<h3 id="익스텐션-문법"><a href="#익스텐션-문법" class="headerlink" title="익스텐션 문법"></a>익스텐션 문법</h3><p>기존에 존재하는 타입이 추가로 다른 프로토콜을 채택할 수 있도록 확장할 수 있음</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Class</span>: <span class="title">UITableViewDelegate</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="익스텐션으로-추가할-수-있는-기능"><a href="#익스텐션으로-추가할-수-있는-기능" class="headerlink" title="익스텐션으로 추가할 수 있는 기능"></a>익스텐션으로 추가할 수 있는 기능</h3><p>저장 프로퍼티는 추가할 수 없음. 기존 프로퍼티에 프로퍼티 감시자를 추가할 수 없음.</p>
<p>클래스 타입에 지정 이니셜라이저를 추가할 수 없음. 편의 이니셜라이저는 추가할 수 있음</p>
<ul>
<li>클래스 타입에서 지정 이니셜라이저와 디이니셜라이저는 반드시 클래스 구현부에 위치해야 함</li>
</ul>
<p>값 타입에 사용자 정의 이니셜라이저를 정의할 때 기본 이니셜라이저나 멤버와이즈 이니셜라이저를 사용하고 싶다면 익스텐션을 사용하여 사용자 정의 이니셜라이저를 구현하면 된다.</p>
<ul>
<li>모든 저장 프로퍼티에 기본값이 있음<ul>
<li>모든 저장 프로퍼티에 기본값이 있어야 기본 이니셜라이저 <code>init()</code>을 호출할 수 있음</li>
<li>그렇지 않으면 멤버와이즈 이니셜라이저만 호출 가능</li>
</ul>
</li>
<li>타입에 기본 이니셜라이저와 멤버와이즈 이니셜라이저 외 추가 사용자 정의 이니셜라이저가 없을 때</li>
</ul>
<h2 id="제네릭"><a href="#제네릭" class="headerlink" title="제네릭"></a>제네릭</h2><p><strong>중요!</strong></p>
<p>어떠한 타입에도 유연하게 대응 / 제네릭으로 구현한 기능과 타입은 재사용하기 쉬움 / 코드 중복을 줄여 깔끔하고 추상적인 표현이 가능함</p>
<p>제네릭이 필요한 타입 또는 메소드의 이름 뒤 <code>&lt;제네릭을_위한_타입_매개변수&gt;</code>를 명시해준다.</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">제네릭을<span class="number">_</span>사용하고자<span class="number">_</span>하는<span class="number">_</span>타입<span class="number">_</span>이름&lt;타입<span class="number">_</span>매개변수&gt;</span><br><span class="line">제네릭을<span class="number">_</span>사용하고자<span class="number">_</span>하는<span class="number">_</span>함수<span class="number">_</span>이름&lt;타입<span class="number">_</span>매개변수&gt;(함수의<span class="number">_</span>매개변수...)</span><br></pre></td></tr></table></figure>

<p><code>Any</code>를 사용하면 되지 않을까?</p>
<ul>
<li><code>Any</code>는 모든 타입을 나타내는 타입이지만, 타입에 매우 엄격하므로 인자를 항상 <code>Any</code>로 캐스팅 시켜주든지 해야 함</li>
<li>올바른 방법이 아니다.</li>
</ul>
<h3 id="제네릭-함수"><a href="#제네릭-함수" class="headerlink" title="제네릭 함수"></a>제네릭 함수</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">swap</span>&lt;T&gt;<span class="params">(<span class="number">_</span> a: <span class="keyword">inout</span> T, <span class="number">_</span> b: <span class="keyword">inout</span> T)</span></span></span><br></pre></td></tr></table></figure>

<p>제네릭 함수는 실제 타입 이름을 명시하는 대신 플레이스홀더를 사용함. 위에서는 <code>T</code></p>
<p>플레이스홀더는 타입의 종류를 알려주지는 않지만 어떤 타입이라는 것은 알려줌</p>
<ul>
<li><code>a</code>와 <code>b</code>의 매개변수 타입이 같다는 것은 알 수 있음</li>
</ul>
<p><code>T</code>의 실제 타입은 함수가 호출되는 순간 결정됨</p>
<ul>
<li><code>Int</code> 타입 변수가 전달되었다면 <code>T == Int</code></li>
<li><code>String</code> 타입 변수가 전달되었다면 <code>T == String</code></li>
</ul>
<p>플레이스홀더 타입 <code>T</code>는 타입 매개변수의 한 예로 들 수 있음</p>
<ul>
<li>플레이스홀더 타입의 이름을 지정하고 명시함</li>
<li>함수 이름 뒤 <code>&lt;&gt;</code> 안쪽에 위치함 ex) <code>&lt;T&gt;</code></li>
<li>타입 매개변수는 함수의 매개변수 타입, 함수의 반환형, 함수 내부 변수의 타입 지정에 사용될 수 있음<ul>
<li>타입 매개변수는 함수를 호출할 때마다 실제 타입으로 치환됨</li>
</ul>
</li>
<li>여러 개의 타입 매개변수를 갖기 위해 <code>&lt;T, U, V&gt;</code>와 같은 형식으로 작성할수도 있음</li>
</ul>
<p>타입 매개변수는 대부분 의미 있는 이름을 가지나, 특별히 관계의 의미를 이름으로 표현하기 어려울 때는 관용적으로 <code>T</code>, <code>U</code>, <code>V</code> 등의 대문자 한 글자로 표현함</p>
<ul>
<li><code>Dictionary&lt;Key, Value&gt;</code></li>
<li><code>Array&lt;Element&gt;</code></li>
<li><code>func swap&lt;T&gt;</code></li>
<li>타입 매개변수 이름 또한 타입 이름이므로 대문자 캐멀케이스 사용</li>
</ul>
<h3 id="제네릭-타입"><a href="#제네릭-타입" class="headerlink" title="제네릭 타입"></a>제네릭 타입</h3><p><strong>제네릭 타입을 구현하여 사용자 정의 타입인 구조체, 클래스, 열거형 등이 어떤 타입과도 연관되어 동작할 수 있게 함</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>&lt;<span class="title">Element</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> items: [<span class="type">Element</span>] = []</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">push</span><span class="params">(<span class="number">_</span> item: Element)</span></span> &#123;</span><br><span class="line">        items.append(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">pop</span><span class="params">()</span></span> -&gt; <span class="type">Element</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items.removeLast()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Element == Int</span></span><br><span class="line"><span class="keyword">let</span> intStack = <span class="type">Stack</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line"><span class="comment">// Element == String</span></span><br><span class="line"><span class="keyword">let</span> stringStack = <span class="type">Stack</span>&lt;<span class="type">String</span>&gt;()</span><br></pre></td></tr></table></figure>

<p>타입의 인스턴스를 생성할 때 <code>&lt;&gt;</code> 안에 실제 사용될 타입을 명시함. 해당 타입에만 동작하도록 제한할 수 있어 더욱 안전하고 의도한 대로 기능을 사용하도록 유도할 수 있음</p>
<h3 id="제네릭-타입-확장"><a href="#제네릭-타입-확장" class="headerlink" title="제네릭 타입 확장"></a>제네릭 타입 확장</h3><p>제네릭을 사용하는 타입에 기능을 추가하고자 익스텐션을 사용한다면, 익스텐션 정의에 타입 매개변수를 명시하지 않아야 한다. 대신 원래의 제네릭 정의에 명시한 타입 매개변수를 익스텐션에서 사용할 수 있다.</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> top: <span class="type">Element?</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items.last</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> bottom: <span class="type">Element?</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items.first</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items.<span class="built_in">count</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="타입-제약"><a href="#타입-제약" class="headerlink" title="타입 제약"></a>타입 제약</h3><p>타입 매개변수가 가져야 할 제약사항을 지정할 수 있음</p>
<ul>
<li>제네릭 함수가 처리해야 할 기능이 특정 타입에 한정될 수 있음</li>
<li>제네릭 타입을 특정 프로토콜을 준수하는 타입만 사용할 수 있게 한정할 수 있음</li>
</ul>
<p><strong>클래스 타입 또는 프로토콜로만 타입 제약을 줄 수 있음</strong></p>
<ul>
<li>특정 클래스를 상속받는 타입인가</li>
<li>특정 프로토콜을 준수하는 타입인가</li>
</ul>
<p>타입 매개변수를 명시하는 자리 뒤에 <code>:</code>을 붙이고 타입 제약을 걸 클래스나 프로토콜을 명시함</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapTwoValues</span>&lt;T: BinaryInteger&gt;<span class="params">(<span class="number">_</span> a: <span class="keyword">inout</span> T, <span class="number">_</span> b: <span class="keyword">inout</span> T)</span></span> &#123; ... &#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>&lt;<span class="title">Element</span>: <span class="title">Hashable</span>&gt; </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>여러 제약을 추가하기 위해 <code>where</code>절을 사용할 수 있음</p>
<ul>
<li><code>&lt;&gt;</code> 안에 쉼표로 여러 개의 제약 조건을 나열하는 것이 아님</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapTwoValues</span>&lt;T: BinaryInteger&gt;<span class="params">(<span class="number">_</span> a: <span class="keyword">inout</span> T, <span class="number">_</span> b: <span class="keyword">inout</span> T)</span></span> <span class="keyword">where</span> <span class="type">T</span>: <span class="type">FloatingPoint</span>, <span class="type">T</span>: <span class="type">Equatable</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p><strong>타입 제약에 자주 사용할 만한 프로토콜</strong></p>
<ul>
<li><code>Hashable</code> / <code>Equatable</code> / <code>Comparable</code> / <code>Indexable</code> / <code>IteratorProtocol</code> / <code>Error</code> / <code>Collection</code> / <code>CustomStringConvertible</code> 등</li>
</ul>
<p>타입 매개변수마다 제약 조건을 달리하여 구현할 수 있음</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">function</span>&lt;Key: Hashable, Value&gt;<span class="params">(key: Key, value: Value)</span></span> -&gt; <span class="type">Dictionary</span>&lt;<span class="type">Key</span>, <span class="type">Value</span>&gt; &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<h3 id="프로토콜의-연관-타입"><a href="#프로토콜의-연관-타입" class="headerlink" title="프로토콜의 연관 타입"></a>프로토콜의 연관 타입</h3><p><strong>프로토콜에서 사용할 수 있는 플레이스홀더 이름</strong></p>
<p><code>associatedtype</code> 키워드 사용</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">ItemType</span></span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(<span class="number">_</span> item: ItemType)</span></span></span><br><span class="line">    <span class="keyword">subscript</span>(i: <span class="type">Int</span>) -&gt; <span class="type">ItemType</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>실제 프로토콜 정의를 준수하기 위해 구현할 때는 <code>ItemType</code>을 하나의 타입으로 일관성 있게 구현하면 됨</p>
<p><code>ItemType</code>을 어떤 타입으로 사용할지 명확히 하고 싶다면 <code>typealias ItemType = Int</code>와 같이 명시해줄 수 있음</p>
<p>제네릭 타입에서는 연관 타입과 타입 매개변수를 대응시킬 수 있음 <code>typealias ItemType = Element</code></p>
<ul>
<li><code>typealias</code> 해주는 것이 자동완성에 유리한 것 같음</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// typealias 하지 않아 ItemType을 하나의 타입으로 일관성 있게 구현</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyContainer</span>: <span class="title">Container</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> items: [<span class="type">Int</span>] = []</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items.<span class="built_in">count</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(<span class="number">_</span> item: Int)</span></span> &#123;</span><br><span class="line">        items.append(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">subscript</span>(i: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// typealias 하여 ItemType을 프로토콜 구현 시 사용할 수도 있음</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YourContainer</span>: <span class="title">Container</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">ItemType</span> = <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> items: [<span class="type">ItemType</span>] = []</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items.<span class="built_in">count</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(<span class="number">_</span> item: String)</span></span> &#123;</span><br><span class="line">        items.append(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">subscript</span>(i: <span class="type">Int</span>) -&gt; <span class="type">ItemType</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 제네릭 타입에서 연관 타입과 타입 매개변수를 대응시킴</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>&lt;<span class="title">Element</span>&gt;: <span class="title">Container</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">ItemType</span> = <span class="type">Element</span></span><br><span class="line">    <span class="keyword">var</span> items: [<span class="type">ItemType</span>] = []</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(<span class="number">_</span> item: Element)</span></span> &#123;</span><br><span class="line">        items.append(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items.<span class="built_in">count</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">subscript</span>(i: <span class="type">Int</span>) -&gt; <span class="type">ItemType</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="제네릭-서브스크립트"><a href="#제네릭-서브스크립트" class="headerlink" title="제네릭 서브스크립트"></a>제네릭 서브스크립트</h3><p>서브스크립트도 제네릭을 활용하여 타입에 큰 제한 없이 유연하게 구현할 수 있고, 타입 제약을 사용하여 제네릭을 활용하는 타입에 제약을 줄 수 있음</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 익스텐션으로 기능을 추가할 때 타입 매개변수를 다시 정의할 필요 없음</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">subscript</span>&lt;<span class="type">Indices</span>: <span class="type">Sequence</span>&gt;(<span class="built_in">indices</span>: <span class="type">Indices</span>) -&gt; [<span class="type">ItemType</span>] <span class="keyword">where</span> <span class="type">Indices</span>.<span class="type">Iterator</span>.<span class="type">Element</span> == <span class="type">Int</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Stack()[0...2]와 같이 서브스크립트 호출 가능</span></span><br></pre></td></tr></table></figure>

<h2 id="프로토콜-지향-프로그래밍"><a href="#프로토콜-지향-프로그래밍" class="headerlink" title="프로토콜 지향 프로그래밍"></a>프로토콜 지향 프로그래밍</h2><p>Swift의 표준 라이브러리에서 타입과 관련된 것들은 대부분 구조체로 구현되어 있음</p>
<p>상속도 되지 않는 구조체가 이토록 다양한 공통 기능을 갖게 된 것은 <strong>프로토콜, 익스텐션, 제네릭</strong> 덕분임</p>
<h3 id="프로토콜-초기구현"><a href="#프로토콜-초기구현" class="headerlink" title="프로토콜 초기구현"></a>프로토콜 초기구현</h3><p>특정 프로토콜을 정의하여 여러 타입에서 이 프로토콜을 준수하게 만들 때, 타입마다 같은 메소드, 프로퍼티, 서브스크립트 등을 구현해야 하는 경우 코드의 중복, 유지보수 등에서 문제를 발생시킬 것이다.</p>
<p><strong>프로토콜 초기구현</strong> : 프로토콜의 익스텐션에서 프로토콜이 요구하는 기능을 실제로 구현할 수 있음</p>
<p>프로토콜 초기구현을 해두었어도 특정 프로토콜을 준수하는 타입에 해당 프로토콜을 구현할 수 있음</p>
<ul>
<li>타입에 프로토콜이 요구하는 기능이 구현되어 있다면 그 기능을 호출</li>
<li>그렇지 않다면 프로토콜 초기구현으로 구현된 기능을 호출</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 프로토콜 정의</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SelfPrintable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">printSelf</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Container 프로토콜을 준수하는 곳에서의 SelfPrintable 프로토콜 추기구현</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SelfPrintable</span> <span class="title">where</span> <span class="title">Self</span>: <span class="title">Container</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">printSelf</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(items)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Container 프로토콜은 SelfPrintable 프로토콜을 준수함</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Container</span>: <span class="title">SelfPrintable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">ItemType</span></span><br><span class="line">    <span class="keyword">var</span> items: [<span class="type">ItemType</span>] &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(<span class="number">_</span> item: ItemType)</span></span></span><br><span class="line">    <span class="keyword">subscript</span>(i: <span class="type">Int</span>) -&gt; <span class="type">ItemType</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Container 프로토콜 초기구현</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(<span class="number">_</span> item: ItemType)</span></span> &#123;</span><br><span class="line">        items.append(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items.<span class="built_in">count</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">subscript</span>(i: <span class="type">Int</span>) -&gt; <span class="type">ItemType</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Popable 프로토콜은 Container 프로토콜을 준수함</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Popable</span>: <span class="title">Container</span> </span>&#123;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">pop</span><span class="params">()</span></span> -&gt; <span class="type">ItemType?</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">push</span><span class="params">(<span class="number">_</span> item: ItemType)</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Popable 프로토콜 초기구현</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Popable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">pop</span><span class="params">()</span></span> -&gt; <span class="type">ItemType?</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items.removeLast()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">push</span><span class="params">(<span class="number">_</span> item: ItemType)</span></span> &#123;</span><br><span class="line">        items.append(item)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Container 프로토콜은 items 프로퍼티를 제외하고 모두 초기구현 되어있어 현 상황에서 다시 구현해줄 필요는 없음</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>&lt;<span class="title">Element</span>&gt;: <span class="title">Container</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">ItemType</span> = <span class="type">Element</span></span><br><span class="line">    <span class="keyword">var</span> items: [<span class="type">Element</span>] = []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> stack = <span class="type">Stack</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">stack.printSelf()	<span class="comment">// []</span></span><br></pre></td></tr></table></figure>

<ul>
<li>각각의 요소 타입은 제네릭을 통해 사용할 때 결정하므로 타입에 대해 매우 유연하게 동작할 수 있음<ul>
<li>클래스의 경우 다중상속이 불가하므로 부모클래스의 기능으로 부족하다면 자식클래스에서 다시 구현해야 함</li>
<li>프로토콜 초기구현을 한 프로토콜을 채택하면 상속도, 초기 구현도 필요 없음</li>
<li>여러 프로토콜을 채택할 수 있음</li>
</ul>
</li>
</ul>
<p><strong>프로토콜 지향 프로그래밍의 핵심 컨셉트 중 하나</strong></p>
<ul>
<li>프로토콜 초기구현을 통해 기능을 구현한다면 프로토콜 채택만으로 타입에 기능을 추가하여 사용할 수 있음</li>
</ul>
<h3 id="맵-필터-리듀스-직접-구현하기"><a href="#맵-필터-리듀스-직접-구현하기" class="headerlink" title="맵, 필터, 리듀스 직접 구현하기"></a>맵, 필터, 리듀스 직접 구현하기</h3><h4 id="맵"><a href="#맵" class="headerlink" title="맵"></a>맵</h4><p>자신이 갖는 요소 <code>Element</code> 타입을 어떠한 타입으로 변환시키는 함수를 전달받아 구현하기</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;T&gt;<span class="params">(transform: <span class="params">(Element)</span></span></span> -&gt; <span class="type">T</span>) -&gt; <span class="type">Stack</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> transformed = <span class="type">Stack</span>&lt;<span class="type">T</span>&gt;()</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> items &#123;</span><br><span class="line">        transformed.items.append(transform(item))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> transformed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="필터"><a href="#필터" class="headerlink" title="필터"></a>필터</h3><p>전달받은 함수와 일치하는 조건의 경우만 반환하게 구현하기</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">filter</span><span class="params">(includesElement: <span class="params">(Element)</span></span></span> -&gt; <span class="type">Bool</span>) -&gt; <span class="type">Stack</span>&lt;<span class="type">Element</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> filtered = <span class="type">Stack</span>&lt;<span class="type">Element</span>&gt;()</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> items &#123;</span><br><span class="line">        <span class="keyword">if</span> includesElement(item) &#123;</span><br><span class="line">            filtered.items.append(item)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> filtered</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="리듀스"><a href="#리듀스" class="headerlink" title="리듀스"></a>리듀스</h3><p>초기값을 전달받고, 전달받은 함수를 수행하여 초기값에 할당하는 식으로 구현하기</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reduce</span>&lt;T&gt;<span class="params">(<span class="number">_</span> initial: T, combine: <span class="params">(T, Element)</span></span></span> -&gt; <span class="type">T</span>) -&gt; <span class="type">T</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result = initial</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> items &#123;</span><br><span class="line">        result = combine(result, item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="기본-타입-확장"><a href="#기본-타입-확장" class="headerlink" title="기본 타입 확장"></a>기본 타입 확장</h3><p>사용자 정의 프로토콜을 정의하고, 프로토콜 초기구현으로 구현해 놓은 프로토콜을 익스텐션을 사용하여 기본 타입에 기능을 추가할 수 있음</p>

  </div>
</article>

    <div class="blog-post-comments">
        <div id="disqus_thread">
            <noscript>Please enable JavaScript to view the comments.</noscript>
        </div>
    </div>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Posts</a></li>
         
          <li><a href="/tags/">Tag</a></li>
         
          <li><a href="/categories/">Category</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#확장"><span class="toc-number">1.</span> <span class="toc-text">확장</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#서브스크립트"><span class="toc-number">1.1.</span> <span class="toc-text">서브스크립트</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#상속"><span class="toc-number">1.2.</span> <span class="toc-text">상속</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#클래스-상속"><span class="toc-number">1.2.1.</span> <span class="toc-text">클래스 상속</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#재정의"><span class="toc-number">1.2.2.</span> <span class="toc-text">재정의</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#프로퍼티-재정의"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">프로퍼티 재정의</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#프로퍼티-감시자-재정의"><span class="toc-number">1.2.3.</span> <span class="toc-text">프로퍼티 감시자 재정의</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#서브스크립트-재정의"><span class="toc-number">1.2.4.</span> <span class="toc-text">서브스크립트 재정의</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#재정의-방지"><span class="toc-number">1.2.5.</span> <span class="toc-text">재정의 방지</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#클래스의-이니셜라이저-상속과-재정의"><span class="toc-number">1.3.</span> <span class="toc-text">클래스의 이니셜라이저 - 상속과 재정의</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#지정-이니셜라이저와-편의-이니셜라이저"><span class="toc-number">1.3.1.</span> <span class="toc-text">지정 이니셜라이저와 편의 이니셜라이저</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#클래스의-초기화-위임"><span class="toc-number">1.3.2.</span> <span class="toc-text">클래스의 초기화 위임</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2단계-초기화"><span class="toc-number">1.3.3.</span> <span class="toc-text">2단계 초기화</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#이니셜라이저-상속-및-재정의"><span class="toc-number">1.3.4.</span> <span class="toc-text">이니셜라이저 상속 및 재정의</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#이니셜라이저-자동-상속"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">이니셜라이저 자동 상속</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#요구-이니셜라이저"><span class="toc-number">1.3.5.</span> <span class="toc-text">요구 이니셜라이저</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#타입캐스팅"><span class="toc-number">1.4.</span> <span class="toc-text">타입캐스팅</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#기존-언어의-타입-변환과-스위프트의-타입-변환"><span class="toc-number">1.4.1.</span> <span class="toc-text">기존 언어의 타입 변환과 스위프트의 타입 변환</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#스위프트-타입캐스팅"><span class="toc-number">1.4.2.</span> <span class="toc-text">스위프트 타입캐스팅</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#데이터-타입-확인"><span class="toc-number">1.4.3.</span> <span class="toc-text">데이터 타입 확인</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#다운캐스팅"><span class="toc-number">1.4.4.</span> <span class="toc-text">다운캐스팅</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Any-AnyObject의-타입캐스팅"><span class="toc-number">1.4.5.</span> <span class="toc-text">Any, AnyObject의 타입캐스팅</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#프로토콜"><span class="toc-number">1.5.</span> <span class="toc-text">프로토콜</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#프로토콜이란"><span class="toc-number">1.5.1.</span> <span class="toc-text">프로토콜이란</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#프로토콜-요구사항"><span class="toc-number">1.5.2.</span> <span class="toc-text">프로토콜 요구사항</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#프로퍼티-요구"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">프로퍼티 요구</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#메소드-요구"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">메소드 요구</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#가변-메소드-요구"><span class="toc-number">1.5.2.3.</span> <span class="toc-text">가변 메소드 요구</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#이니셜라이저-요구"><span class="toc-number">1.5.2.4.</span> <span class="toc-text">이니셜라이저 요구</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#프로토콜의-상속-클래스-전용-프로토콜"><span class="toc-number">1.5.3.</span> <span class="toc-text">프로토콜의 상속 클래스 전용 프로토콜</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#프로토콜-조합과-프로토콜-준수-확인"><span class="toc-number">1.5.4.</span> <span class="toc-text">프로토콜 조합과 프로토콜 준수 확인</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#프로토콜의-선택적-요구"><span class="toc-number">1.5.5.</span> <span class="toc-text">프로토콜의 선택적 요구</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#프로토콜-변수와-상수"><span class="toc-number">1.5.6.</span> <span class="toc-text">프로토콜 변수와 상수</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#위임을-위한-프로토콜"><span class="toc-number">1.5.7.</span> <span class="toc-text">위임을 위한 프로토콜</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#익스텐션"><span class="toc-number">1.6.</span> <span class="toc-text">익스텐션</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#익스텐션-문법"><span class="toc-number">1.6.1.</span> <span class="toc-text">익스텐션 문법</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#익스텐션으로-추가할-수-있는-기능"><span class="toc-number">1.6.2.</span> <span class="toc-text">익스텐션으로 추가할 수 있는 기능</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#제네릭"><span class="toc-number">1.7.</span> <span class="toc-text">제네릭</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#제네릭-함수"><span class="toc-number">1.7.1.</span> <span class="toc-text">제네릭 함수</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#제네릭-타입"><span class="toc-number">1.7.2.</span> <span class="toc-text">제네릭 타입</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#제네릭-타입-확장"><span class="toc-number">1.7.3.</span> <span class="toc-text">제네릭 타입 확장</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#타입-제약"><span class="toc-number">1.7.4.</span> <span class="toc-text">타입 제약</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#프로토콜의-연관-타입"><span class="toc-number">1.7.5.</span> <span class="toc-text">프로토콜의 연관 타입</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#제네릭-서브스크립트"><span class="toc-number">1.7.6.</span> <span class="toc-text">제네릭 서브스크립트</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#프로토콜-지향-프로그래밍"><span class="toc-number">1.8.</span> <span class="toc-text">프로토콜 지향 프로그래밍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#프로토콜-초기구현"><span class="toc-number">1.8.1.</span> <span class="toc-text">프로토콜 초기구현</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#맵-필터-리듀스-직접-구현하기"><span class="toc-number">1.8.2.</span> <span class="toc-text">맵, 필터, 리듀스 직접 구현하기</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#맵"><span class="toc-number">1.8.2.1.</span> <span class="toc-text">맵</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#필터"><span class="toc-number">1.8.3.</span> <span class="toc-text">필터</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#리듀스"><span class="toc-number">1.8.4.</span> <span class="toc-text">리듀스</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#기본-타입-확장"><span class="toc-number">1.8.5.</span> <span class="toc-text">기본 타입 확장</span></a></li></ol></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://presto95.github.io/2020/01/18/%EC%95%BC%EA%B3%B0%EC%9D%98-%EC%8A%A4%EC%9C%84%ED%94%84%ED%8A%B8-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%99%95%EC%9E%A5/" target="_blank" rel="noopener"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://presto95.github.io/2020/01/18/%EC%95%BC%EA%B3%B0%EC%9D%98-%EC%8A%A4%EC%9C%84%ED%94%84%ED%8A%B8-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%99%95%EC%9E%A5/&text=야곰의 스위프트 프로그래밍 - 확장" target="_blank" rel="noopener"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://presto95.github.io/2020/01/18/%EC%95%BC%EA%B3%B0%EC%9D%98-%EC%8A%A4%EC%9C%84%ED%94%84%ED%8A%B8-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%99%95%EC%9E%A5/&title=야곰의 스위프트 프로그래밍 - 확장" target="_blank" rel="noopener"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://presto95.github.io/2020/01/18/%EC%95%BC%EA%B3%B0%EC%9D%98-%EC%8A%A4%EC%9C%84%ED%94%84%ED%8A%B8-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%99%95%EC%9E%A5/&is_video=false&description=야곰의 스위프트 프로그래밍 - 확장" target="_blank" rel="noopener"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=야곰의 스위프트 프로그래밍 - 확장&body=Check out this article: http://presto95.github.io/2020/01/18/%EC%95%BC%EA%B3%B0%EC%9D%98-%EC%8A%A4%EC%9C%84%ED%94%84%ED%8A%B8-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%99%95%EC%9E%A5/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://presto95.github.io/2020/01/18/%EC%95%BC%EA%B3%B0%EC%9D%98-%EC%8A%A4%EC%9C%84%ED%94%84%ED%8A%B8-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%99%95%EC%9E%A5/&title=야곰의 스위프트 프로그래밍 - 확장" target="_blank" rel="noopener"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://presto95.github.io/2020/01/18/%EC%95%BC%EA%B3%B0%EC%9D%98-%EC%8A%A4%EC%9C%84%ED%94%84%ED%8A%B8-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%99%95%EC%9E%A5/&title=야곰의 스위프트 프로그래밍 - 확장" target="_blank" rel="noopener"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://presto95.github.io/2020/01/18/%EC%95%BC%EA%B3%B0%EC%9D%98-%EC%8A%A4%EC%9C%84%ED%94%84%ED%8A%B8-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%99%95%EC%9E%A5/&title=야곰의 스위프트 프로그래밍 - 확장" target="_blank" rel="noopener"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://presto95.github.io/2020/01/18/%EC%95%BC%EA%B3%B0%EC%9D%98-%EC%8A%A4%EC%9C%84%ED%94%84%ED%8A%B8-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%99%95%EC%9E%A5/&title=야곰의 스위프트 프로그래밍 - 확장" target="_blank" rel="noopener"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://presto95.github.io/2020/01/18/%EC%95%BC%EA%B3%B0%EC%9D%98-%EC%8A%A4%EC%9C%84%ED%94%84%ED%8A%B8-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%99%95%EC%9E%A5/&name=야곰의 스위프트 프로그래밍 - 확장&description=" target="_blank" rel="noopener"><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://news.ycombinator.com/submitlink?u=http://presto95.github.io/2020/01/18/%EC%95%BC%EA%B3%B0%EC%9D%98-%EC%8A%A4%EC%9C%84%ED%94%84%ED%8A%B8-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%99%95%EC%9E%A5/&t=야곰의 스위프트 프로그래밍 - 확장" target="_blank" rel="noopener"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2020 Presto
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Posts</a></li>
         
          <li><a href="/tags/">Tag</a></li>
         
          <li><a href="/categories/">Category</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">


<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">


    <!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>

<!-- clipboard -->

  
<script src="/lib/clipboard/clipboard.min.js"></script>

  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Disqus Comments -->

    <script type="text/javascript">
        var disqus_shortname = 'presto95';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>


</body>
</html>
